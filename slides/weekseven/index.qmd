---
title: "Implementing Stacks, Queues, and Deques"
echo: true
description: "How do you use proofs to measure the performance of a Python program?"
date: "2024-02-26"
date-format: long
author: Gregory M. Kapfhammer
execute:
  freeze: auto
format:
  revealjs:
    theme: default
    css: styles.css
    monofont: Ubuntu Mono
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    html-math-method: mathjax
    footer: "Algorithmology"
---

# What is an abstract data type? How to compare it to a data structure?

::: fragment

- **Abstract Data Type (ADT)**: the interface of a data structure
- **Concrete Data Structure (CDS)**: the implementation of ADT
- ADT is *independent* of implementation concerns in the CDS

:::

## Understanding the connection between and ADT and a CDS {transition="convex"}

::: {.fragment .fade-right style="margin-top: -0.1em; font-size: 0.95em;"}

- **Abstract data type**

    - What is the *data* to be stored or represented?
    - What are the *processes* that manipulate the data?
    - Avoids specifying how the data is stored or manipulated

- **Concrete data structure**

    - Delivered as a class in a Python program
    - Implements and efficient version of data type
    - Specifies how the data is stored and manipulated

:::

## An ADT and its CDS are the basic building blocks of programs!

- **Stack**: ADT for a last-in, first-out (LIFO) list
- **Queue**: ADT for a first-in, first-out (FIFO) list
- **Deque**: ADT for a flexible, double-ended queue
- Each data structure has **trade-offs** in its:
  - Features
  - Time overhead
  - Space overhead

# Specifying and implementing the `Stack` abstract data type

- Data storage and access according to the **LIFO discipline**
- Implemented in a object-oriented fashion using composition
- Balances the need for **flexibility** and **efficiency**
- Be careful! Poor implementations can be inefficient!

## `Stack` abstract data type

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.9em;"}

- **push** - add a new item to the stack
- **pop** - remove and return the next item in LIFO order
- **peek** - return the next item in LIFO order
- **size** - returns the number of items in the stack
- **isempty** - return `True` if storing no items or return `False`

:::

::: {.fragment .fade style="margin-top: -0.1em; font-size: 0.9em;"}

- Implementation details:
    - The `Stack` wraps a `list` in a Python class
    - Use the name of the `Stack` to give implementation clues
    - Let's explore the first implementation called `ListStack`!

:::

## `ListStack` implements the `Stack` ADT

```{python}
class ListStack:
    def __init__(self):
        self._L = []

    def push(self, item):
        self._L.append(item)

    def pop(self):
        return self._L.pop()

    def peek(self):
        return self._L[-1]

    def __len__(self):
        return len(self._L)

    def isempty(self):
        return len(self) == 0
```

::: {.fragment .fade-left style="margin-top: 0.1em; font-size: 0.9em;"}

- The `ListStack` uses a `list` called `_L` to store data items

:::

