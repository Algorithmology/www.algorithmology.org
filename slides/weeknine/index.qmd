---
title: "Implementing Linked-Based Data Structures"
echo: true
description: "How do you design and implement linked-based data structures in Python?"
date: "2024-03-11"
date-format: long
author: Gregory M. Kapfhammer
execute:
  freeze: auto
format:
  revealjs:
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    html-math-method: mathjax
    footer: "Algorithmology"
    mermaid:
      theme: default
---

# What is a linked list?

- Stores a sequential collection of elements
- Uses individual nodes to store data values
- Each node has a reference to the next node
- The first node is called the **head** and the last is the **tail**

```{python}
class ListNode:
    def __init__(self, data, link = None):
        self.data = data
        self.link = link
```

## Implementing a `LinkedList`

```{python}
class LinkedList:
    def __init__(self):
        self._head = None

    def addfirst(self, item):
        self._head = ListNode(item, self._head)

    def removefirst(self):
        item = self._head.data
        self._head = self._head.link
        return item
```

::: {.fragment style="margin-top: 0.5em"}

- A `LinkedList` contains an instance of `ListNode` in `_head`
- `addfirst` creates a new `ListNode` and updates `_head`
- `removefirst` updates `_head` and returns the data

:::

## Making a `Queue` with a `LinkedList`

```{python}
#| code-line-numbers: "|1-6|8-15|17-20|22-31|"
class LinkedList:
    def __init__(self):
        self._head = None

    def addfirst(self, item):
        self._head = ListNode(item, self._head)

    def addlast(self, item):
        if self._head is None:
            self.addfirst(item)
        else:
            currentnode = self._head
            while currentnode.link is not None:
                currentnode = currentnode.link
            currentnode.link = ListNode(item)

    def removefirst(self):
        item = self._head.data
        self._head = self._head.link
        return item

    def removelast(self):
        if self._head.link is None:
            return self.removefirst()
        else:
            currentnode = self._head
            while currentnode.link.link is not None:
                currentnode = currentnode.link
            item = currentnode.link.data
            currentnode.link = None
            return item
```

## Using the `LinkedList`

```{python}
LL = LinkedList()
LL.addfirst(3)
LL.addfirst(5)
print(LL.removefirst() == 5)
LL.addlast(9)
LL.addlast(13)
print(LL.removefirst() == 3)
print(LL.removefirst() == 9)
print(LL.removelast() == 13)
```

::: {.fragment style="font-size: 0.9em"}

- This `LinkedList` can be used to build a `Queue`
- However, two of these methods have `while` loops!
- This means it is not always better than the `ListQueue`

:::

## Concerns about this `LinkedList`?

::: {.panel-tabset}

### {{< iconify fa6-solid circle-exclamation >}} `addlast`

```python
def addlast(self, item):
    if self._head is None:
        self.addfirst(item)
    else:
        currentnode = self._head
        while currentnode.link is not None:
            currentnode = currentnode.link
        currentnode.link = ListNode(item)
```

- The `while currentnode.link is not None` is not efficient
- Access to the final node requires traversing the entire list
- This is a $O(n)$ (or linear-time) operation!

### {{< iconify fa6-solid circle-exclamation >}} `removelast`

```python
def removelast(self):
    if self._head.link is None:
        return self.removefirst()
    else:
        currentnode = self._head
        while currentnode.link.link is not None:
            currentnode = currentnode.link
        item = currentnode.link.data
        currentnode.link = None
        return item
```

- `while currentnode.link.link is not None` not efficient
- `removelast` traverses all nodes to find second-to-last one

:::

## Better `Queue` with a `LinkedList`

```{python}
#| code-line-numbers: "|1-4|6-15|17-21|21-33|"
class LinkedListNew:
    def __init__(self):
        self._head = None
        self._tail = None

    def addfirst(self, item):
        self._head = ListNode(item, self._head)
        if self._tail is None: self._tail = self._head

    def addlast(self, item):
        if self._head is None:
            self.addfirst(item)
        else:
            self._tail.link = ListNode(item)
            self._tail = self._tail.link

    def removefirst(self):
        item = self._head.data
        self._head = self._head.link
        if self._head is None: self._tail = None
        return item

    def removelast(self):
        if self._head is self._tail:
            return self.removefirst()
        else:
            currentnode = self._head
            while currentnode.link is not self._tail:
                currentnode = currentnode.link
            item = self._tail.data
            self._tail = currentnode
            self._tail.link = None
            return item
```

## Using the new `LinkedList`

```{python}
LL = LinkedListNew()
LL.addfirst(3)
LL.addfirst(5)
print(LL.removefirst() == 5)
LL.addlast(9)
LL.addlast(13)
print(LL.removefirst() == 3)
print(LL.removefirst() == 9)
print(LL.removelast() == 13)
```

::: {.fragment style="font-size: 0.9em"}

- This `LinkedList` can be used to build a `Queue`
- However, two of these methods have `while` loops!
- This means it is not always better than the `ListQueue`

:::

## Concerns about new `LinkedList`?

::: {.panel-tabset}

### {{< iconify fa6-solid circle-check >}} `addlast`

```python
def addlast(self, item):
    if self._head is None:
        self.addfirst(item)
    else:
        self._tail.link = ListNode(item)
        self._tail = self._tail.link
```

- There is no longer a `while` loop in `addlast`
- When there is no data, `addfirst` is called
- Otherwise, `self._tail` is updated and new node is added
- Adding a node to the end of the list is now $O(1)$!

### {{< iconify fa6-solid circle-exclamation >}} `removelast`

```python
def removelast(self):
    if self._head is self._tail:
        return self.removefirst()
    else:
        currentnode = self._head
        while currentnode.link is not self._tail:
            currentnode = currentnode.link
        item = self._tail.data
        self._tail = currentnode
        self._tail.link = None
        return item
```

- `while currentnode.link is not self._tail` not efficient
- `removelast` still traverses all nodes to perform a removal!

:::

## `LinkedQueue` with a `LinkedList`

```{python}
#| code-line-numbers: "|1-3|5-14|16-20|"
class LinkedQueue:
    def __init__(self):
        self._L = LinkedListNew()

    def enqueue(self, item):
        self._L.addlast(item)

    def dequeue(self):
        return self._L.removefirst()

    def peek(self):
        item = self._L.removefirst()
        self._L.addfirst(item)
        return item

    def __len__(self):
        return len(self._L)

    def isempty(self):
        return len(self) == 0
```

## Tracking the size of a `LinkedList`

```{python }
#| code-line-numbers: "|1-5|7-18|20-25|27-41|"
class LinkedList:
    def __init__(self):
        self._head = None
        self._tail = None
        self._length = 0

    def addfirst(self, item):
        self._head = ListNode(item, self._head)
        if self._tail is None: self._tail = self._head
        self._length += 1

    def addlast(self, item):
        if self._head is None:
            self.addfirst(item)
        else:
            self._tail.link = ListNode(item)
            self._tail = self._tail.link
            self._length += 1

    def removefirst(self):
        item = self._head.data
        self._head = self._head.link
        if self._head is None: self._tail = None
        self._length -= 1
        return item

    def removelast(self):
        if self._head is self._tail:
            return self.removefirst()
        else:
            currentnode = self._head
            while currentnode.link is not self._tail:
                currentnode = currentnode.link
            item = self._tail.data
            self._tail = currentnode
            self._tail.link = None
            self._length -= 1
            return item

    def __len__(self):
        return self._length
```

