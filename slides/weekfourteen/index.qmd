---
title: "Priority Queues"
echo: true
description: "How do you support priority-oriented data access?"
date: "2024-04-15"
date-format: long
author: Gregory M. Kapfhammer
execute:
  freeze: auto
format:
  revealjs:
    theme: default
    css: styles.css
    monofont: Ubuntu Mono
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    html-math-method: mathjax
    footer: "Algorithmology"
---

# What is a priority queue? Why is it useful?

::: incremental

- Normally data items removed based on insertion order
- Now, data items are removed based on priority!
- Queue that supports priority-oriented data access
- Aim to have good performance for all key operations

:::

::: {.fragment .fade}

{{< iconify game-icons team-idea >}} **Any examples of data we should store in a priority queue?**

:::

## Main methods in a `PriorityQueue` API

::: {.fragment .fade-up .boxed-content style="margin-top: 0em; font-size: 0.80em;"}

- `insert(item, priority)`: Add `item` with the given `priority`.

- `findmin()` - Return the item with the minimum priority. If there are
multiple items with the minimum priority, ties may be broken arbitrarily.

- `removemin()` - Remove and return the item with the minimum priority. As with
the `findmin` method, ties are broken arbitrarily.

:::

::: incremental

- Use a list-based approach for a starting implementation
- Identify performance trade-offs when using a list
- Develop a new data structure called a `heap`
- Use the `heap` to support efficient priority queue operations

:::

## Using a `list` for a `PriorityQueue`

```{python}
class SimpleListPQ:
    def __init__(self):
        self._L = []

    def insert(self, item, priority):
        self._L.append((item, priority))

    def findmin(self):
        return min(self._L, key = lambda x : x[1])[0]

    def removemin(self):
        item, priority = min(self._L, key = lambda x : x[1])
        self._L.remove((item, priority))
        return item
```

::: fragment

- The variable `_L` is a `list` of tuples stored in `self`
- Each tuple stores an `item` and its `priority`
- Both `findmin` and `removemin` have $O(n)$ time complexity

:::

## Creating and using a `SimpleListPQ`

```{python}
pq = SimpleListPQ()

pq.insert('apple', 3)
pq.insert('banana', 1)
pq.insert('cherry', 2)

print(pq.findmin())    # Outputs: 'banana'
print(pq.removemin())  # Outputs: 'banana'
print(pq.findmin())    # Outputs: 'cherry'
```

::: {.fragment style="font-size: 0.85em;"}

- The first parameter to `insert` method is the `item`
- The second parameter to `insert` method is the `priority`
- The `findmin` method returns the item with minimum priority
- The `removemin` method removes and returns item with minimum priority

:::

## Creating an `Entry` class

```{python}
class Entry:
    def __init__(self, item, priority):
        self.priority = priority
        self.item = item

    def __lt__(self, other):
        return self.priority < other.priority
```

::: {.fragment style="font-size: 0.95em;"}

- Indexing the `tuple` in the `list` is error-prone for `SimpleListPQ`
- Alternatively, use an `Entry` class to store `item` and `priority`
- The `__init__` constructor initializes the `item` and `priority`
- The `__lt__` method compares the priorities of two `Entry`s
- A lower `priority` value indicates a higher priority item!
- Now, we can use this to build `UnsoredListPQ`!

:::

## Creating the `UnsortedListPQ` class

```{python}
class UnsortedListPQ:
    def __init__(self):
        self._entries = []

    def insert(self, item, priority):
        self._entries.append(Entry(item, priority))

    def findmin(self):
        return min(self._entries).item

    def removemin(self):
        entry = min(self._entries)
        self._entries.remove(entry)
        return entry.item
```

::: {.fragment style="font-size: 0.925em; margin-top: 0.5em;"}

- The `insert` method has a worst-case time complexity of $O(1)$
- The `findmin` and `removemin` methods have a worst-case time complexity of
$O(n)$ because the `min` function is $O(n)$

:::

## Creating the `SortedListPQ` class

```{python}
class SortedListPQ:
    def __init__(self):
        self._entries = []

    def insert(self, item, priority):
        self._entries.append(Entry(item, priority))
        self._entries.sort(reverse = True)

    def findmin(self):
        return self._entries[-1].item

    def removemin(self):
        return self._entries.pop().item
```

::: {.fragment style="font-size: 0.85em; margin-top: 0.5em;"}

- `findmin` and `removemin` have a worst-case time complexity of $O(1)$
- However, now `insert` has worst-case time complexity of $O(n \log n)$!
- Wait, using an insertion sort could improve performance of `insert`!

:::

# What are the trade-offs in the `SortedListPQ`?

- Trade-offs exist between the time complexity of the `insert` method and the
`findmin` and `removemin` methods

- In one system, we have fast `insert` and slow `removemin` and in the other we
have slow `insert` and fast `removemin`

- Achieve constant or logarithmic time complexity for all?

- Need a new data structure to achieve this ambitious goal!

## Exploring the `heap` data structure

####  Priority Queues and Heaps

- Priority Queue: Abstract Data Type (ADT)
- Heap: Data Structure used to implement a Priority Queue

#### Vocabulary Issues

- Many types of heaps exist, we'll focus on Binary Heap
- The term "key" is often used for "priority" in a heap

#### Binary Heap

- A binary tree with smaller priorities above larger ones
