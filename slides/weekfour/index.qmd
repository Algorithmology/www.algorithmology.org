---
title: "Software Testing"
echo: true
description: "How do you establish a confidence in the correctness of a Python program?"
date: "2024-02-05"
date-format: long
author: Gregory M. Kapfhammer
format:
  revealjs:
    theme: default
    css: styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Algorithmology"
---

# Software programs must work correctly

::: incremental

- **Data structures**: does each structure store data correctly?
- **Algorithm**: does each algorithm produce the correct output?
- **Benchmarks**: is software under study invoked correctly?
- **Data Storage**: do the benchmarks store data correctly?
- **Data Analysis**: does the software analyze data correctly?

:::

## By running a program and checking its output software testing establishes a confidence in its correctness

::: {.fragment .fade-right}

- Steps during software testing:
    - Create an input for the program
    - Setup the program's environment
    - Pass the input to the program
    - Collect the output from the program
    - Compare the output to the expected output

:::

## How would you test the `Doubler`?

```{python}
class Doubler:
    def __init__(self, n):
        self._n = 2 * n

    def n(self):
        return self._n

x = Doubler(5)
print(x.n() == 10)
assert(x.n() == 10)
y = Doubler(-4)
print(y.n() == -8)
assert(y.n() == -8)
```

::: {.fragment .fade-left style="margin-top: -0.25em; font-size: 0.9em;"}

- Establishes a confidence in the correctness of the `Doubler` class
- When testing is it better to use `print` or `assert` statements?

:::

## Best practices for software testing

::: {.fragment .fade-right}

- Answer the following questions when testing:
    - Does the program meet its specification?
    - After changing the program, does it still work correctly?
- Using assertion statements:
    - `print` statements require manual checking of output
    - `assert` statements automatically checks correctness
- Use a testing framework like `pytest` or `unittest`
- Assess the adequacy of the test suite with `coverage.py`

:::

## `unittest` for `DayOfTheWeek`

```{python}
import unittest
from dayoftheweek import DayOfTheWeek

class TestDayOfTheWeek(unittest.TestCase):
    def test_init(self):
        d = DayOfTheWeek('F')
        self.assertEqual(d.name(), 'Friday')
        d = DayOfTheWeek('Th')
        self.assertEqual(d.name(), 'Thursday')

unittest.main(argv=['ignored'], verbosity=2, exit=False)
```

::: {.fragment .fade-left style="margin-top: 0.25em; font-size: 1.0em;"}

- Call `unittest.main` differently for tests outside Quarto
- Run `test_dayoftheweek.py` in `slides/weekfour/`
- The `OK` output confirms that the assertions passed

:::

## Explore `DayOfTheWeek`

```python
class DayOfTheWeek:
    """A class to represent a day of the week."""
    def __init__(self, abbreviation):
        """Create a new DayOfTheWeek object."""
        self.abbreviation = abbreviation
        self.name_map = {
            "M": "Monday",
            "T": "Tuesday",
            "W": "Wednesday",
            "Th": "Thursday",
            "F": "Friday",
            "Sa": "Saturday",
            "Su": "Sunday",
        }

    def name(self):
        return self.name_map.get(self.abbreviation)
```

::: {.fragment .fade-right style="margin-top: 0.5em; font-size: 0.9em;"}

- Support the lookup of a day of the week through an abbreviation

:::

# Exploring test-driven development in Python

::: incremental

- **Data structures**: does each structure store data correctly?
- **Algorithm**: does each algorithm produce the correct output?
- **Benchmarks**: is software under study invoked correctly?
- **Data Storage**: do the benchmarks store data correctly?
- **Data Analysis**: does the software analyze data correctly?

:::
