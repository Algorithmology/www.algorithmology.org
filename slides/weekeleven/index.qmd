---
title: "Searching and Sorting"
echo: true
description: "How do you efficiently process data?"
date: "2024-03-25"
date-format: long
author: Gregory M. Kapfhammer
execute:
  freeze: auto
format:
  revealjs:
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    html-math-method: mathjax
    footer: "Algorithmology"
---

# What are purposes of searching and sorting?

- Searching finds a specific item in a collection
- Sorting orders the items in a collection
- Recursive and iterative algorithms are possible
- Basic building blocks of many algorithms

## Recursive `binary_search`

```{python}
def binary_search(L, item):
    if len(L) == 0: return False
    median = len(L) // 2
    if item == L[median]:
        return True
    elif item < L[median]:
        return binary_search(L[:median], item)
    else:
        return binary_search(L[median + 1:], item)

print(binary_search([1, 2, 3, 4, 5], 3))   # Output: True
print(binary_search([2, 4, 6, 8, 10], 5))  # Output: False
```

::: {.fragment style="font-size: 0.85em; margin-top: -0.2em"}

- Searches for a single `item` in a sorted list `L`
- Recursively calls itself with a smaller list
- Returns `True` if the `item` is found, `False` otherwise

:::

## Improved `binary_search`

```{python}
def fast_binary_search(L, item, left = 0, right = None):
    if right is None: right = len(L)
    if right - left == 0: return False
    if right - left == 1: return L[left] == item
    median = (right + left) // 2
    if item < L[median]:
        return fast_binary_search(L, item, left, median)
    else:
        return fast_binary_search(L, item, median, right)

print(fast_binary_search([1, 2, 3, 4, 5], 3))   # Output: True
print(fast_binary_search([2, 4, 6, 8, 10], 5))  # Output: False
```

::: {.fragment style="font-size: 0.85em; margin-top: -0.2em"}

- Use of list slicing in `binary_search` slows it down!
- Function call tree has length at most $O(\log n)$
- Example of both **linear** and **tail** recursion

:::

## Iterative `binary_search`

```{python}
def iterative_binary_search(L, item):
    left, right = 0, len(L)
    while right - left > 1:
        median = (right + left) // 2
        if item < L[median]:
            right = median
        else:
            left = median
    return right > left and L[left] == item

print(iterative_binary_search([1, 2, 3, 4, 5], 3))   # Output: True
print(iterative_binary_search([2, 4, 6, 8, 10], 5))  # Output: False
```

::: {.fragment style="font-size: 0.85em; margin-top: -0.2em"}

- Tail recursion can normally be replaced with iteration
- This function also has worst-case time complexity of $O(\log n)$
- Example of both **linear** and **tail** recursion

:::

# Let's explore several sorting algorithms!

::: fragment

- Quadratic time sorting algorithms are easy to implement
- Mergesort and quicksort are efficient yet harder to build
- Python contains its own sorting algorithm called `timsort`
- The divide and conquer paradigm is useful for sorting

:::

## Quadratic-time sorting

```{python}
def issorted(L):
    for i in range(len(L)-1):
        if L[i]>L[i+1]:
            return False
    return True

A = [1,2,3,4,5]
print(A, "is sorted:", issorted(A))

B = [1,4,5,7,2]
print(B, "is sorted:", issorted(B))
```

<p class="tightspacer"></p>

#### {{< iconify fa6-solid bolt >}} How do we know if a list is sorted?

::: {.fragment style="font-size: 0.85em; margin-top: -0.4em"}

- Confirm that adjacent elements are in the correct order
- Use a single `for` loop to compare adjacent elements in `L`

:::
