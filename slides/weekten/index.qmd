---
title: "Recursion and Dynamic Programming"
echo: true
description: "How do you efficiently repeat operations?"
date: "2024-03-18"
date-format: long
author: Gregory M. Kapfhammer
execute:
  freeze: auto
format:
  revealjs:
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    html-math-method: mathjax
    footer: "Algorithmology"
---

# Recursion means a "reference to self"!

- Implementation of recursion in Python language
- Mental model for how to think about recursive functions
- Use of recursion as a problem solving technique
- Analysis of the running time of recursive functions

## Recursive implementation of `sumk`

```{python}
def sumk(k):
    if k > 0:
        return sumk(k-1) + k
    return 0

print(sumk(1))
print(sumk(2))
print(sumk(3))
print(sumk(4))
print(sumk(5))
```

::: fragment

- The `sumk` function calls itself with a smaller value of `k`
- The base case stops the recursion when `k` is equal to `0`

:::

## Termination of recursive functions

::: fragment

- **How to ensure that a recursive function stops running?**

  - Base case stops the recursion by returning fixed value
  - Recursive case reduces the input towards the base case
  - Recursive calls are made of smaller sub-problems

- **What happens if the base case is not reached?**
  - The recursive function will enter an infinite recursion
  - Python limits adding recursive functions to call stack 
  - The program will ultimately raise the `RecursionError`

:::

## The call stack and recursion

```{python}
def sumsquarek(k):
    if k == 0:
        return 0
    else:
        return k ** 2 + sumsquarek(k - 1)

print(sumsquarek(1))  # Output: 1
print(sumsquarek(2))  # Output: 5
print(sumsquarek(3))  # Output: 14
print(sumsquarek(4))  # Output: 30
print(sumsquarek(5))  # Output: 55
```

::: {.fragment style="font-size: 0.9em; margin-top: -0.25em"}

- The `sumsquarek` function calls itself with a smaller value of `k`
- The base case stops the recursion when `k` is equal to `0`

:::

## `RecursionError` with functions

```python
def a(k):
    if k == 0: return 0
    return b(k)

def b(k):
    return c(k)

def c(k):
    return a(k-1)

a(340)
```

::: {.fragment style="font-size: 1em; margin-top: 0.25em"}

- This program will raise a `RecursionError` in Python
- Interestingly, it does not contain a recursive function!
- Error signals that Python reached limit of call stack

:::

## `RecursionError` with `list`s

```python
A = [2]
B = [2]
A.append(A)
B.append(B)
A == B
```

::: {.fragment style="font-size: 1em; margin-top: 0.25em"}

- `list.__eq__` method that compares two lists for `==` use
- The first elements of `A` and `B` are equal
- The second elements of `A` and `B` are actually lists
- This causes another call to the `list.__eq__` method
- Ultimately, this leads to a `RecursionError` in Python
- Recursion is elegant but can lead to unexpected errors!

:::

## Iterative and recursive Fibonacci

```{python}
def fibonacci_recursive(k):
    if k in [0,1]: return k
    return fibonacci_recursive(k-1) + fibonacci_recursive(k-2)

print([fibonacci_recursive(i) for i in range(10)])
```

<p class="codespacer">

```{python}
def fibonacci_iterative(k):
    a, b = 0,1
    for i in range(k):
        a, b = b, a + b
    return a

print([fibonacci_iterative(i) for i in range(10)])
```

::: {.fragment style="font-size: 1em; margin-top: -0.2em"}

- Both approaches compute the Fibonacci sequence. Which one do you think is
faster? Why do you think that is the case?

:::

## Recursive greatest common divisor

```{python}
def gcd(a, b):
    if a == b:
        return a
    if a > b:
        a, b = b, a
    return gcd(a, b - a)

print("GCD of 12 and 513 is", gcd(12, 513))
print("GCD of 19 and 513 is", gcd(19, 513))
print("GCD of 19 and 515 is", gcd(515, 19))
```

::: {.fragment style="font-size: 1em; margin-top: 0.25em"}

- Computes the greatest common divisor of two numbers
- Too many recursive calls when `b` is much larger than `a`!

:::

## Revising the recursive `gcd`

```{python}
def gcd(a, b):
    if a > b:
        a, b = b, a
    if a == 0:
        return b
    return gcd(a, b % a)

print("GCD of 12 and 513 is", gcd(12, 513))
print("GCD of 19 and 513 is", gcd(19, 513))
print("GCD of 19 and 515 is", gcd(515, 19))
```

::: {.fragment style="font-size: 1em; margin-top: 0.25em"}

- Both approach compute the same sequence of values
- Depending on inputs, one approach may be more efficient

:::

# What is dynamic programming?

::: fragment

- Solve a problem using solutions to sub-problems
- Often starts with an inefficient recursive algorithm
- Memoization stores the results of expensive function calls
- Tabulation stores the results of a bottom-up computation

:::

## Defective Greedy Change-Making

```{python}
def greedyMC(coinvalueList, change):
    coinvalueList.sort()
    coinvalueList.reverse()
    numcoins = 0
    for c in coinvalueList:
        numcoins += change // c
        change = change % c
    return numcoins

print(greedyMC([1, 5, 10, 25], 63))
print(greedyMC([1, 21, 25], 63))    # Incorrect, should be 3
print(greedyMC([1, 5, 21, 25], 63)) # Incorrect, should be 3
```

::: fragment

- What is the minimum number of coins to make change for `63` cents? This
`greedyMC` only works for canonical coin systems!

:::

## Slow Recursive Change-Making

```python
def recMC(coinValueList, change):
   minCoins = change
   if change in coinValueList:
     return 1
   else:
      for i in [c for c in coinValueList if c <= change]:
         numCoins = 1 + recMC(coinValueList,change-i)
         if numCoins < minCoins:
            minCoins = numCoins
   return minCoins

print(recMC([1, 5, 10, 25], 63))
print(recMC([1, 21, 25], 63))
print(recMC([1, 5, 21, 25], 63))
```

::: fragment

- The `recMC` function calls itself with a smaller value of `change`
- Works correctly --- but is very slow for certain input values!

:::

## Memoized Recursive Change-Making

```{python}
def memoMC(coinValueList, change, knownResults):
    minCoins = change
    if change in coinValueList:
        knownResults[change] = 1
        return 1
    elif change in knownResults:
        return knownResults[change]
    else:
        for i in [c for c in coinValueList if c <= change]:
            numCoins = 1 + memoMC(coinValueList, change-i, knownResults)
            if numCoins < minCoins:
                minCoins = numCoins
                knownResults[change] = minCoins
    return minCoins

knownresults = {}
print(f"{memoMC([1, 5, 10, 21, 25], 63, knownresults)} coins needed.", end=" ")
print(f"Wow, computed {len(knownresults)} intermediate results!", end=" ")
```
