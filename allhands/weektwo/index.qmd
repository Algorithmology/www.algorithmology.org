---
author: [Sabrina Rodriguez, Evan Nelson, Jason Gymafi, Rebekah Rudd, Simon Jones]
title: How can we validate the calculated time complexity of an averaging function?
page-layout: full
categories: [post, average, matrix]
date: "2024-03-22"
date-format: long
toc: true
---

# Introduction

The purpose of this project is to develop a benchmarking system that will allow us to 
calculate the fastest running time execution amongst various solution to one function. Below 
is a sample of the function we had to solve:


```python
def find_average_value(matrix: List[List[int]]) -> Union[float, None]:
    """Find the average value in the provided matrix."""
    ...
```
Below are our samples on how we approached this problem: 

## Rebekah Rudd Solution

```python
def find_average_value(matrix: List[List[int]]) -> Union[float, None]:
    """Find the average value in the provided matrix."""
    # check to see if matrix is populated
    if not matrix:
        return None
    # create an empty list
    total_numbers = []
    # iterate through matrix and extract all the numbers to find the min
    for number_list in matrix:
        for number in number_list:
            total_numbers.append(number)
    # return the minimum value within the total_numbers list using min()
    return sum(total_numbers) / len(total_numbers)
```

## Sabrina Rodriguez Solution

```python
def find_average_value(matrix: List[List[int]]) -> Union[float, None]:
    """Find the average value in the provided matrix."""
    if not matrix or not all(
        isinstance(row, list) and all(isinstance(val, int) for val in row)
        for row in matrix
    ):
        return None
    total_sum = sum(sum(row) for row in matrix)
    num_elements = sum(len(row) for row in matrix)
    return total_sum / num_elements
```

## Simon Jones Solution

```python
def find_average_value(matrix: List[List[int]]) -> Union[float, None]:
    """Find the average value in the provided matrix."""
    if not isinstance(matrix, list) or len(matrix) == 0:
        return None
    matrix_flatmapped: List[int] = []
    for listy in matrix:
        matrix_flatmapped = matrix_flatmapped + listy
    return sum(matrix_flatmapped) / len(matrix_flatmapped)
```

# Estimated Runtime Complexity

## Simon Jones Solution

The estimated runtime complexity of Simon's solution was calculated to be

$$
O\Bigg(n_1 + 2n_1n_2 + \frac{1}{2}n_2(n_1^3 + n_1^2)\Bigg)
$$

The reason for which is explained in the following code. The time complexity of each code snippet is denoted with a comment above it.

```python
def find_average_value(matrix: List[List[int]]) -> Union[float, None]:
    """Find the average value in the provided matrix."""
    # O(n_1)
    if not isinstance(matrix, list) or len(matrix) == 0:
        return None
    matrix_flatmapped: List[int] = []
    # O(n_1)
    for listy in matrix:
        # O(i * n_2 + n_2)
        matrix_flatmapped = matrix_flatmapped + listy
    # O(2 * n_1 * n_2)
    return sum(matrix_flatmapped) / len(matrix_flatmapped)
```

Calculating the time complexity of this gets us the following:

$$
O\Bigg(n_1 + 2n_1 n_2 + n_1\Bigg(\sum_{i=0}^{n-1}in_2 + n_2\Bigg)\Bigg)
$$

Which can be simplified to our final expression:

$$
O\Bigg(n_1 + 2n_1n_2 + \frac{1}{2}n_2(n_1^3 + n_1^2)\Bigg)
$$

Upon comparing these two results, we find that the theoretical result differs greatly from the experimental result. The experimental time complexity, when $n_1$ is held constant, varies exponentially with $n_2$, which goes against the theoretical time complexity for which $O$ would vary lienarly if $n_1$ were held constant.
