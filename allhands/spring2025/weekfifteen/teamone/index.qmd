---
author: [Anoop Guragain,Kris Hatcher,Anton Hedlund,Rosa Ruiz,Molly Suppo]
title: How does implementing a tree with Python's set and list structures impact performance in terms of insertion, deletion, and lookup speed?
page-layout: full
categories: [post, tree, set, list, speed, performance]
date: "2025-04-24"
date-format: long
toc: true
---

# Introduction

TODO: content here

## Motivation

TODO: content here

## Approach

### Generate Trees for Analysis

I have two separate generation algorithms to handle the different data types used for this experiment, lists and sets.
Regardless, both generate unordered integer pairs within the container specified in the function name. Both functions also
handle the case where there is not enough nodes present to make a tree. To generate a tree, there needs to be at least two
nodes, a parent or root node, and a child node. If there are not enough nodes, an error is raised explaining why a tree will
not be generated.

The node pairs are generated using the random library and it's function, `randint`. The values generated are random integers
between `0` and `1000`. Nodes are generated until the number of nodes generated is the equal to the value of the parameter
`num_nodes`. The root or parent node is then assigned as the first node inside the container with the utilization of the `pop`
function and the value `0` or the first index in the list specified. The available parents list is started with the root node
as the first entry.

For each value in the randomly generated list of values for the nodes, the parents are randomly selected and a pair consisting
of the parent value and the child's value are added to the tree. For sets, the `add` function is used and for lists, the
`append` function is used. Then the available parent list is updated with the value of the child node.

At the end of both functions, the tree is returned either as a set or a list that contains pairs of unordered integers.

### Process Tree Created Using `Set` Container

TODO: Rosa to describe her code here

### Process Tree Created Using `List` Container

TODO: Anton to describe his code here

### Run a Benchmark

TODO: Anoop to describe his code here

## Raw Data

TODO: Kris to convert Google Sheet into Markdown Table

# Charts

TODO: Kris to create charts to demonstrate data

# Results

TODO: write up findings

# Next Steps

TODO: write up recommended next steps

# References

1. Documentation
    - [Python Lists](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists)
    - [pytest Documentation](https://docs.pytest.org/en/stable/)
    - [geeksforgeeks](https://www.geeksforgeeks.org/python-dictionary-update-method/)
    - [Tree Data Structures](https://en.wikipedia.org/wiki/Tree_(data_structure))
    - [Rich Library for Tables](https://rich.readthedocs.io/en/stable/tables.html)
    - [Graph vs Tree Data Structures](https://www.geeksforgeeks.org/difference-between-graph-and-tree/)
2. Course Slides
    - [Hierarchical Data Structures Course Slides](https://algorithmology.org/slides/weekthirteen/)

## AI Usage in this Project

AI was used in this project for:

- Tree generation algorithms (adapted from Microsoft Copilot)
- Code optimization and refactoring suggestions
- Test case generation and documentation templates
- Error handling and debugging support
- Generating sample data for testing
- Bug correction
- Writing documentation
- Autocompletion of repetitive code snippets

All AI-generated content was reviewed and validated by team members.
