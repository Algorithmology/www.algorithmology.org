---
author: [Hemani Alaparthi, Grant Anderson, Will Bennett, Coltin Colucci, Vivian Potts, Megan Wolfarth]
title: How does the presence of duplicate entries in primary sorting attributes affect the runtime (ms) of a Multi-Level-Comparison-Sorting Algorithm (an approach that sequentially evaluates attributes to resolve ties)?
page-layout: full
categories: [post, sorting, multi-level, algorithms, runtime]
date: "2025-03-28"
date-format: long
toc: true
format:
    html:
        code-links:    
            - text: Github Repository
              icon: github
              href: https://github.com/hemanialaparthi/wapbac-sorting
---

# Introduction

In modern data processing, efficient sorting is foundational to everything from database operations to machine learning pipelines. While most algorithms excel with unique keys, real-world datasets frequently contain duplicate entries in primary attributes like `name` or `country`. These duplicates usually require algorithms to resolve ties through sequential comparisons of secondary attributes (e.g., `phone_number`, `email`) or an attribute chosen by a user that can be deemed as an `tie-breaker` attribute.

## Motivation

Duplicate entries in primary sorting attributes (e.g., `name`, `country`) are common and when these duplicates occur, sorting algorithms must resolve ties using secondary attributes or attributes inputted by the user that can be considered a 'secondary' attribute, creating a need for efficient **multi-level comparison strategies**. This study analyzes how duplicate rates impact three sorting algorithms (`Bubble Sort`, `QuickSort`, and `Timsort`) when handling multi-level comparisons, providing insights into algorithm selection for real-world data processing.

# Method

## Approach

At the core of our analysis is multi-level sorting logic. We implemented three sorting paradigms with configurable attribute prioritization:

### Bubble Sort

```python
def sort_persons_bubblesort_multilevel(
    persons: List[Person], attribute: str
) -> List[Person]:

    # define the tie-breaking attributes (e.g., secondary and tertiary attributes)
    tie_breaking_attributes = ["name", "country", "phone_number", "job", "email"]

    length_of_persons = len(persons)
    for i in range(length_of_persons):
        for j in range(0, length_of_persons - i - 1):
            # compare records based on the primary attribute
            value1 = getattr(persons[j], attribute)
            value2 = getattr(persons[j + 1], attribute)

            if value1 == value2:
                # if the values are equal, use tie-breaking attributes
                swap = False
                for tie_attr in tie_breaking_attributes:
                    tie_value1 = getattr(persons[j], tie_attr)
                    tie_value2 = getattr(persons[j + 1], tie_attr)
                    if tie_value1 > tie_value2:
                        swap = True
                        break
                    elif tie_value1 < tie_value2:
                        break
            else:
                # if values are not equal, determine if a swap is needed
                swap = value1 > value2

            # swap if necessary
            if swap:
                persons[j], persons[j + 1] = persons[j + 1], persons[j]
    return persons
```

This `bubblesort_multilevel` algorithm implementation extends the classic algorithm by introducing hierarchical attribute comparisons. While traditional `Bubble Sort` compares elements using a single attribute, this version first evaluates the primary attribute (e.g., `country`), then sequentially checks secondary attributes (`name` → `phone_number` → `job` → `email`) to resolve ties - effectively implementing lexicographical ordering. Each comparison may require up to six attribute checks (primary + five tie-breakers), increasing computational overhead from O(n²) to O(kn²) where k represents attribute tiers.

### Quick Sort

```python
def sort_persons_quicksort_multilevel(
   persons: List[Person], attribute: str
) -> List[Person]:
   """Optimized multi-level quicksort with early comparison shortcut"""
   if len(persons) <= 1:
       return persons


   # Define tie-breakers and precompute getters
   tie_breakers = ["name", "country", "phone_number", "job", "email"]
   # combines primary sorting attribute with tie_breakers into list
   keys = [attribute] + tie_breakers
   # create list of getter functions for each attribute in keys list
   getters = [attrgetter(key) for key in keys]
  
   # Initialize stack
   stack = [(0, len(persons) - 1)]
  
   # Process ranges iteratively until empty
   while stack:
       # Get current range to process
       low, high = stack.pop()
       # skip of range is invalid or sorted
       if low >= high:
           continue
      
       # Median-of-three pivot selection
       mid = (low + high) // 2 # Calculate middle index of current range


       # Compare element with first
       # If the last element is smaller swap to ensure the first element is smaller
       if getters[0](persons[high]) < getters[0](persons[low]):
           persons[low], persons[high] = persons[high], persons[low]


       # Compare with middle element with the first element
       # if middle element smaller swap them
       if getters[0](persons[mid]) < getters[0](persons[low]):
           persons[mid], persons[low] = persons[low], persons[mid]
      
       # Compare the last element with the middle element
       # if last element smaller swap to ensure middle element is smaller
       if getters[0](persons[high]) < getters[0](persons[mid]):
           persons[high], persons[mid] = persons[mid], persons[high]
      
       # Select pivot element
       pivot = persons[mid]
       pivot_vals = [getter(pivot) for getter in getters]
      
       # initialize pointers for partitioning
       i, j = low, high
      
       # Partition the range while two pointers have not crossed
       while i <= j:


           # Left scan: Move 'i' right
           while True:
               # Get primary attribute at index 'i'
               left_primary = getters[0](persons[i])
               # exit early if
               if left_primary != pivot_vals[0]:
                   if left_primary >= pivot_vals[0]:
                       break
                   # otherwise move pointer right
                   i += 1
                   continue
              
               left_vals = [left_primary] + [getter(persons[i]) for getter in getters[1:]]
               if left_vals >= pivot_vals:
                   break
               i += 1
          
           # Right scan with early exit
           while True:
               # Get primary attribute from index 'j'
               right_primary = getters[0](persons[j])
               # If primary value is not equal to pivots
               # Current value is <= pivots primary value
               # Stop scanning otherwise continue
               if right_primary != pivot_vals[0]:
                   if right_primary <= pivot_vals[0]:
                       break
                   j -= 1
                   continue
              
               # if primary value matches pivot - tiebreak
               # Stop scanning if element <= pivot
               right_vals = [right_primary] + [getter(persons[j]) for getter in getters[1:]]
               if right_vals <= pivot_vals:
                   break
               j -= 1
          
           # Swap elements if pointers haven't crossed
           # Ensures elements in the correct position
           if i <= j:
               persons[i], persons[j] = persons[j], persons[i]
               i += 1 # Move left pointer right
               j -= 1 # Move right pointer left
      
       # Push smaller partition first
       if (j - low) < (high - i):
           stack.append((low, j))
           stack.append((i, high))
       else:
           stack.append((i, high))
           stack.append((low, j))
  
   return persons
   ```
   
The 'quicksort_multilevel' algorithm is an addition to the classic QuickSort algorithm. With this implementation you can hierarchically compare attributes. You have your primary attribute (e.g., country) and then you can sequentially check the secondary attributes (name -> job -> email -> phone_number) in order to resolve duplicate entries.


This is achieved through an iterative approach with a stack that manages sub-ranges (low, high). This algorithm also uses a median of three pivot because it allows there to be more evenly sized partitions and improved efficiency by making by making the pivot closer to the median value. During partitioning there are two pointers (i and j) are used to scan the range.


For this particular data set there may be up to five attribute checks (primary + 4 tie-breakers). The big O notation from this would usually be O(n log n) but because of the additional attribute comparisons it is O(k n log n) where k is the number of attribute tiers.

### Tim Sort

```py
@timer("Time to Sort Person Data Using Timsort with Multi-Level Sorting (ms)")
def sort_persons_timsort_multilevel(
    persons: List[Person], attribute: str
) -> List[Person]:
    """Sort a list of Person objects using Timsort with multi-level comparison"""
    # Define the tie-breaking attributes (e.g., secondary and tertiary attributes)
    tie_breaking_attributes = ["name", "country", "phone_number", "job", "email"]

    # Create a composite key function for multi-level sorting
    def composite_key(person: Person):
        primary_value = getattr(person, attribute)
        tie_values = tuple(getattr(person, tie_attr) for tie_attr in tie_breaking_attributes)
        return (primary_value, *tie_values)

    # Use Timsort (Python's built-in sorted function) with the composite key
    sorted_persons = sorted(persons, key=composite_key)
    return sorted_persons
```

The `sort_persons_timsort_multilevel` function compares the list with multiple attributes if two entries share similar attrbutes. The function first makes a list of the tie breaking attributes. It enters them into a composite key function to form a tuple of the attributes. The tuple holds the primary sorting attribute, the one input when running the algorithm via terminal command, followed by the other attributes. It then uses python's built in `sorted` with the tuple key to sort the file. 

# Data

## Data Tables

# Results

# Future work
