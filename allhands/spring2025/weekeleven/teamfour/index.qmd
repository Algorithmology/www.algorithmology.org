---
author: [Hemani Alaparthi, Grant Anderson, Will Bennett, Coltin Colucci, Vivian Potts, Megan Wolfarth]
title: How does the presence of duplicate entries in primary sorting attributes affect the runtime (ms) of a Multi-Level-Comparison-Sorting Algorithm (an approach that sequentially evaluates attributes to resolve ties)?
page-layout: full
categories: [post, sorting, multi-level, algorithms, runtime]
date: "2025-03-28"
date-format: long
toc: true
format:
    html:
        code-links:    
            - text: Github Repository
              icon: github
              href: https://github.com/hemanialaparthi/wapbac-sorting
---

# Introduction

In modern data processing, efficient sorting is foundational to everything from database operations to machine learning pipelines. While most algorithms excel with unique keys, real-world datasets frequently contain duplicate entries in primary attributes like `name` or `country`. These duplicates usually require algorithms to resolve ties through sequential comparisons of secondary attributes (e.g., `phone_number`, `email`) or an attribute chosen by a user that can be deemed as an `tie-breaker` attribute.

## Motivation

Duplicate entries in primary sorting attributes (e.g., `name`, `country`) are common and when these duplicates occur, sorting algorithms must resolve ties using secondary attributes or attributes inputted by the user that can be considered a 'secondary' attribute, creating a need for efficient **multi-level comparison strategies**. This study analyzes how duplicate rates impact three sorting algorithms (`Bubble Sort`, `QuickSort`, and `Timsort`) when handling multi-level comparisons, providing insights into algorithm selection for real-world data processing.

# Method

## Approach

At the core of our analysis is multi-level sorting logic. We implemented three sorting paradigms with configurable attribute prioritization:

### Bubble Sort

```python
def sort_persons_bubblesort_multilevel(
    persons: List[Person], attribute: str
) -> List[Person]:

    # define the tie-breaking attributes (e.g., secondary and tertiary attributes)
    tie_breaking_attributes = ["name", "country", "phone_number", "job", "email"]

    length_of_persons = len(persons)
    for i in range(length_of_persons):
        for j in range(0, length_of_persons - i - 1):
            # compare records based on the primary attribute
            value1 = getattr(persons[j], attribute)
            value2 = getattr(persons[j + 1], attribute)

            if value1 == value2:
                # if the values are equal, use tie-breaking attributes
                swap = False
                for tie_attr in tie_breaking_attributes:
                    tie_value1 = getattr(persons[j], tie_attr)
                    tie_value2 = getattr(persons[j + 1], tie_attr)
                    if tie_value1 > tie_value2:
                        swap = True
                        break
                    elif tie_value1 < tie_value2:
                        break
            else:
                # if values are not equal, determine if a swap is needed
                swap = value1 > value2

            # swap if necessary
            if swap:
                persons[j], persons[j + 1] = persons[j + 1], persons[j]
    return persons
```

This `bubblesort_multilevel` algorithm implementation extends the classic algorithm by introducing hierarchical attribute comparisons. While traditional `Bubble Sort` compares elements using a single attribute, this version first evaluates the primary attribute (e.g., `country`), then sequentially checks secondary attributes (`name` → `phone_number` → `job` → `email`) to resolve ties - effectively implementing lexicographical ordering. Each comparison may require up to six attribute checks (primary + five tie-breakers), increasing computational overhead from O(n²) to O(kn²) where k represents attribute tiers.

### Quick Sort

### Tim Sort

```py
@timer("Time to Sort Person Data Using Timsort with Multi-Level Sorting (ms)")
def sort_persons_timsort_multilevel(
    persons: List[Person], attribute: str
) -> List[Person]:
    """Sort a list of Person objects using Timsort with multi-level comparison"""
    # Define the tie-breaking attributes (e.g., secondary and tertiary attributes)
    tie_breaking_attributes = ["name", "country", "phone_number", "job", "email"]

    # Create a composite key function for multi-level sorting
    def composite_key(person: Person):
        primary_value = getattr(person, attribute)
        tie_values = tuple(getattr(person, tie_attr) for tie_attr in tie_breaking_attributes)
        return (primary_value, *tie_values)

    # Use Timsort (Python's built-in sorted function) with the composite key
    sorted_persons = sorted(persons, key=composite_key)
    return sorted_persons
```

The `sort_persons_timsort_multilevel` function compares the list with multiple attributes if two entries share similar attrbutes. The function first makes a list of the tie breaking attributes. It enters them into a composite key function to form a tuple of the attributes. The tuple holds the primary sorting attribute, the one input when running the algorithm via terminal command, followed by the other attributes. It then uses python's built in `sorted` with the tuple key to sort the file. 

# Data

## Data Tables

# Results

# Future work
