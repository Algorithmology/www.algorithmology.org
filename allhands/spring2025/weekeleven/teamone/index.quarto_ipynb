{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "author: [Javier Bejarano Jimenez, Finley Banas, Joseph Oforkansi, Anupraj Guragain, Anton Hedlund]\n",
        "title: What is the performance difference, measured in time when running a doubling experiment between a SLL queue, a DLL queue and a queue built with an array based list when performing basic operations?\n",
        "page-layout: full\n",
        "categories: [post, queues, linked lists, doubling experiment]\n",
        "date: \"2025-03-28\"\n",
        "date-format: long\n",
        "toc: true\n",
        "format:\n",
        "  html:\n",
        "    code-links:    \n",
        "      - text: Github Repository\n",
        "        icon: github\n",
        "        href: https://github.com/josephoforkansi/Algorithm-Analysis-All-Hands-Project-Module-2\n",
        "    code-fold: true\n",
        "    code-summary: \"Show the code\"\n",
        "---\n",
        "\n",
        "\n",
        "# Introduction\n",
        "\n",
        "Efficient data structures are crucial for software performance, scalability, and responsiveness. Among these, queues are fundamental, supporting applications such as task scheduling, messaging systems, and real-time data processing. This project investigates the performance differences between three queue implementations: Singly Linked List (SLL), Doubly Linked List (DLL), and Array-based Queue. \n",
        "\n",
        "Our research question is: **What are the performance differences between SLL queue, DLL queue, and Array-based queue implementations when performing basic operations (e.g., `addfirst`, `addlast`, `removefirst`, `removelast`, `add (+)`, and `iadd (+=)`)?** \n",
        "\n",
        "We conducted benchmarking experiments using `SystemSense` to analyze these implementations. Key aspects considered include:\n",
        "\n",
        "- **Algorithmic Complexity**: Evaluating time and space complexity to identify trade-offs.\n",
        "- **Concurrency Considerations**: Assessing behavior in multi-threaded environments.\n",
        "- **Use Case Optimization**: Identifying scenarios where each implementation excels.\n",
        "- **Benchmarking Methodology**: Designing experiments to measure execution times and scaling behavior.\n",
        "\n",
        "This project aims to provide insights into the efficiency of these queue implementations and guide the selection of an optimal data structure based on application requirements.\n",
        "\n",
        "---\n",
        "\n",
        "## Motivation\n",
        "\n",
        "Efficient data structures are critical in real-world applications such as scheduling systems, task management, and networking. Different queue implementations offer trade-offs in performance. This project benchmarks these trade-offs to analyze execution times for various queue operations.\n",
        "\n",
        "---\n",
        "\n",
        "# Queue Implementations Analysis\n",
        "\n",
        "## Queue Structure and FIFO Principle\n",
        "\n",
        "Queues adhere to the **First-In-First-Out (FIFO)** principle, where elements are added at the rear and removed from the front, ensuring sequential processing.\n",
        "\n",
        "## Implementations Overview\n",
        "\n",
        "This project explores three queue implementations:\n",
        "\n",
        "1. **Singly Linked List (SLL) Queue**:\n",
        "   - Uses one-directional nodes with `next` references.\n",
        "   - Maintains both head and tail pointers for efficient operations.\n",
        "   - Each node stores only the value and a `next` reference.\n",
        "\n",
        "2. **Doubly Linked List (DLL) Queue**:\n",
        "   - Uses bidirectional nodes with both `prev` and `next` references.\n",
        "   - Maintains both head and tail pointers.\n",
        "   - Each node stores value, `prev`, and `next` references.\n",
        "\n",
        "3. **Array-based Queue**:\n",
        "   - No explicit node structure; uses a container of elements.\n",
        "   - Optimized for operations at both ends.\n",
        "\n",
        "---\n",
        "\n",
        "## Key Operations\n",
        "\n",
        "All implementations support the following core operations:\n",
        "\n",
        "- **`enqueue`**: Add an element to the rear.\n",
        "- **`dequeue`**: Remove an element from the front.\n",
        "- **`peek`**: View the front element without removing it.\n",
        "- **`__add__`**: Concatenate two queues.\n",
        "- **`__iadd__`**: In-place concatenation. \n",
        "\n",
        "### Example Implementations\n",
        "\n",
        "#### Enqueue Operation (SLL)\n"
      ],
      "id": "3692c35b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def enqueue(self, value: Any) -> None:\n",
        "    \"\"\"Add an element to the end of the queue. O(1) operation using tail pointer.\"\"\"\n",
        "    new_node = Node(value)\n",
        "    if self.is_empty():\n",
        "        self.head = new_node\n",
        "    else:\n",
        "        self.tail.next = new_node  # Directly append at tail\n",
        "    self.tail = new_node  # Update tail pointer\n",
        "    self.size += 1"
      ],
      "id": "63e9467b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Dequeue Operation (DLL)\n",
        "\n",
        "```python\n",
        "def dequeue(self) -> Any:\n",
        "    \"\"\"Remove and return the first element from the queue. O(1) operation.\"\"\"\n",
        "    if self.is_empty():\n",
        "        raise IndexError(\"Queue is empty\")\n",
        "    value = self.head.value\n",
        "    self.head = self.head.next\n",
        "    if self.head is None:\n",
        "        self.tail = None\n",
        "    else:\n",
        "        self.head.prev = None\n",
        "    self.size -= 1\n",
        "    return value\n",
        "```\n",
        "\n",
        "#### Queue Concatenation (Array-based)\n",
        "\n",
        "```python\n",
        "def __add__(self, other: Any) -> Any:\n",
        "    \"\"\"Concatenate two queues. O(n) operation.\"\"\"\n",
        "    result = ListQueueDisplay()\n",
        "    result.items = deque(self.items)  # Copy first queue\n",
        "    result.items.extend(other.items)  # Append second queue\n",
        "    return result\n",
        "```\n",
        "\n",
        "#### Removelast Operation (Array-based)\n",
        "\n",
        "```python\n",
        "def removelast(self) -> Any:\n",
        "    \"\"\"Remove and return the last element from the queue. O(1) operation.\"\"\"\n",
        "    if self.is_empty():\n",
        "        raise IndexError(\"Queue is empty\")\n",
        "    return self.items.pop()  # O(1) operation for deque\n",
        "```\n",
        "\n",
        "#### Timing Mechanism\n",
        "\n",
        "```python\n",
        "def time_operation(func):\n",
        "    \"\"\"Time an operation using high-precision counter.\"\"\"\n",
        "    try:\n",
        "        # Warm up\n",
        "        func()\n",
        "\n",
        "        # Actual timing\n",
        "        start_time = perf_counter()\n",
        "        func()\n",
        "        elapsed = perf_counter() - start_time\n",
        "        return elapsed\n",
        "    except Exception as e:\n",
        "        console.print(f\"[red]Error during operation: {str(e)}[/red]\")\n",
        "        return float(\"nan\")\n",
        "```\n",
        "\n",
        "#### Doubling Experiment\n",
        "\n",
        "```python\n",
        "def doubling(\n",
        "    initial_size: int = typer.Option(10000, help=\"Initial size for doubling experiment\"),\n",
        "    max_size: int = typer.Option(1000000, help=\"Maximum size for doubling experiment\"),\n",
        "    dll: bool = typer.Option(True, help=\"Test DLL implementation\"),\n",
        "    sll: bool = typer.Option(True, help=\"Test SLL implementation\"),\n",
        "    array: bool = typer.Option(True, help=\"Test Array implementation\"),\n",
        "):\n",
        "    \"\"\"Run doubling experiment on queue implementations.\"\"\"\n",
        "    # Create results directory if it doesn't exist\n",
        "    results_dir = Path(\"results\")\n",
        "    results_dir.mkdir(exist_ok=True)\n",
        "\n",
        "    sizes = []\n",
        "    current_size = initial_size\n",
        "    while current_size <= max_size:\n",
        "        sizes.append(current_size)\n",
        "        current_size *= 2\n",
        "\n",
        "    # Dictionary to store all results for plotting\n",
        "    all_results = {}\n",
        "\n",
        "    for approach, queue_class in QUEUE_IMPLEMENTATIONS.items():\n",
        "        if not (\n",
        "            (approach == QueueApproach.dll and dll)\n",
        "            or (approach == QueueApproach.sll and sll)\n",
        "            or (approach == QueueApproach.array and array)\n",
        "        ):\n",
        "            continue\n",
        "\n",
        "        try:\n",
        "            console.print(f\"\\n{approach.value.upper()} Queue Implementation\")\n",
        "            results = {\n",
        "                \"enqueue\": [],\n",
        "                \"dequeue\": [],\n",
        "                \"peek\": [],\n",
        "                \"concat\": [],\n",
        "                \"iconcat\": [],\n",
        "                \"removelast\": [],\n",
        "            }\n",
        "\n",
        "            for size in sizes:\n",
        "                queue = queue_class()\n",
        "                other = queue_class()\n",
        "\n",
        "                # Enqueue\n",
        "                enqueue_time = time_operation(\n",
        "                    lambda: [queue.enqueue(i) for i in range(size)]\n",
        "                )\n",
        "                results[\"enqueue\"].append(enqueue_time)\n",
        "\n",
        "                # Dequeue\n",
        "                dequeue_time = time_operation(\n",
        "                    lambda: [queue.dequeue() for _ in range(size // 2)]\n",
        "                )\n",
        "                results[\"dequeue\"].append(dequeue_time)\n",
        "\n",
        "                # Refill queue\n",
        "                for i in range(size // 2):\n",
        "                    queue.enqueue(i)\n",
        "\n",
        "                # Peek\n",
        "                peek_time = time_operation(\n",
        "                    lambda: [queue.peek() for _ in range(size // 3)]\n",
        "                )\n",
        "                results[\"peek\"].append(peek_time)\n",
        "\n",
        "                # Prepare other queue for concat\n",
        "                for i in range(size // 10):\n",
        "                    other.enqueue(i)\n",
        "\n",
        "                # Concat\n",
        "                concat_time = time_operation(lambda: queue + other)\n",
        "                results[\"concat\"].append(concat_time)\n",
        "\n",
        "                # Iconcat\n",
        "                iconcat_time = time_operation(lambda: queue.__iadd__(other))\n",
        "                results[\"iconcat\"].append(iconcat_time)\n",
        "\n",
        "                # Removelast - test with fixed number of operations (100)\n",
        "                removelast_time = time_operation(\n",
        "                    lambda: [queue.removelast() for _ in range(100)]\n",
        "                )\n",
        "                results[\"removelast\"].append(removelast_time)\n",
        "\n",
        "            # Store results for plotting\n",
        "            all_results[approach.value] = results\n",
        "\n",
        "            # Display results in table\n",
        "            table = Table(\n",
        "                title=f\"{approach.value.upper()} Queue Doubling Experiment Results\",\n",
        "                box=box.ROUNDED,\n",
        "                show_header=True,\n",
        "                header_style=\"bold magenta\",\n",
        "                width=250\n",
        "            )\n",
        "            table.add_column(\"Size (n)\", justify=\"right\", width=12)\n",
        "            table.add_column(\"enq (ms)\", justify=\"right\", width=15)\n",
        "            table.add_column(\"deq (ms)\", justify=\"right\", width=15)\n",
        "            table.add_column(\"peek (ms)\", justify=\"right\", width=15)\n",
        "            table.add_column(\"cat (ms)\", justify=\"right\", width=15)\n",
        "            table.add_column(\"icat (ms)\", justify=\"right\", width=15)\n",
        "            table.add_column(\"rml (ms)\", justify=\"right\", width=15)\n",
        "\n",
        "            for i, size in enumerate(sizes):\n",
        "                row = [f\"{size:,}\"]\n",
        "                for operation in results.keys():\n",
        "                    value = results[operation][i]\n",
        "                    if np.isnan(value):  # Check for NaN\n",
        "                        row.append(\"N/A\")\n",
        "                    else:\n",
        "                        row.append(f\"{value * 1000:.5f}\")  # Show 5 decimal places\n",
        "                table.add_row(*row)\n",
        "\n",
        "            console.print(Panel(table))\n",
        "\n",
        "        except Exception as e:\n",
        "            console.print(f\"[red]Error testing {approach.value}: {str(e)}[/red]\")\n",
        "            import traceback\n",
        "            console.print(traceback.format_exc())\n",
        "\n",
        "    # Generate and save plots\n",
        "    plot_results(sizes, all_results, results_dir)\n",
        "    console.print(f\"[green]Plots saved to [bold]{results_dir}[/bold] directory[/green]\")\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Running and Using the Tool\n",
        "\n",
        "The benchmarking supports three queue implementations:\n",
        "- DLL (Doubly Linked List)\n",
        "- SLL (Singly Linked List)\n",
        "- Array-based Queue\n",
        "\n",
        "### Setting Up\n",
        "\n",
        "To run the benchmarking tool, ensure you have Poetry installed onto your device. Navigate to the project directory and install dependencies if you have not already:\n",
        "\n",
        "`cd analyze && poetry install`\n",
        "\n",
        "### Running the Experiments\n",
        "\n",
        "The tool provides two main benchmarking experiments which can also be access by \n",
        "\n",
        "`poetry run analyze --help`\n",
        "\n",
        "#### Doubling Experiment\n",
        "\n",
        "To run the doubling experiment, execute:\n",
        "\n",
        "`poetry run analyze doubling`\n",
        "\n",
        "This experiment measures how performance will scale with the increasing input sizes. \n",
        "\n",
        "You can also run:\n",
        "`poetry run analyze doubling --help`\n",
        "for more details and detailed apporach\n",
        "\n",
        "#### Implementation Performance Analysis\n",
        "\n",
        "To analyze the performance of individual queue operations, run:\n",
        "\n",
        "`poetry run analyze analyze`\n",
        "\n",
        "This command will provide execution times for operations like `peek`, `dequeue`, and `enqueue` to compare their efficiency.\n",
        "\n",
        "You can also run:\n",
        "`poetry run analyze analyze --help`\n",
        "for more details and detailed apporach\n",
        "\n",
        "## Output Analysis\n",
        "\n",
        "#### Run of Doubling Experiment\n",
        "\n",
        "##### MacOS\n",
        "\n",
        "- Run of `systemsense`\n",
        "\n",
        "```cmd\n",
        "Displaying System Information\n",
        "\n",
        "╭───────────────────────────────────────────────────────── System Information ─────────────────────────────────────────────────────────╮\n",
        "│ ╭──────────────────┬────────────────────────────────────────────────────────────────────────────────────────╮                        │\n",
        "│ │ System Parameter │ Parameter Value                                                                        │                        │\n",
        "│ ├──────────────────┼────────────────────────────────────────────────────────────────────────────────────────┤                        │\n",
        "│ │ battery          │ 73.00% battery life remaining, 7:20:00 seconds remaining                               │                        │\n",
        "│ │ cpu              │ arm                                                                                    │                        │\n",
        "│ │ cpucores         │ 11 cores                                                                               │                        │\n",
        "│ │ cpufrequencies   │ Min: Unknown Mhz, Max: Unknown Mhz                                                     │                        │\n",
        "│ │ datetime         │ 2025-04-28 21:09:46.967008                                                             │                        │\n",
        "│ │ disk             │ Using 14.74 GB of 460.43 GB                                                            │                        │\n",
        "│ │ hostname         │ MacBook-Pro-Anton.local                                                                │                        │\n",
        "│ │ memory           │ Using 7.55 GB of 18.00 GB                                                              │                        │\n",
        "│ │ platform         │ macOS-15.3.2-arm64-arm-64bit                                                           │                        │\n",
        "│ │ pythonversion    │ 3.12.8                                                                                 │                        │\n",
        "│ │ runningprocesses │ 669 running processes                                                                  │                        │\n",
        "│ │ swap             │ Using 1.10 GB of 2.00 GB                                                               │                        │\n",
        "│ │ system           │ Darwin                                                                                 │                        │\n",
        "│ │ systemload       │ Average Load: 3.11, CPU Utilization: 29.70%                                            │                        │\n",
        "│ │ virtualenv       │ /Users/antonhedlund/Library/Caches/pypoetry/virtualenvs/queue-analysis-2LJggUpT-py3.12 │                        │\n",
        "│ ╰──────────────────┴────────────────────────────────────────────────────────────────────────────────────────╯                        │\n",
        "╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n",
        "\n",
        "Displaying Benchmark Results\n",
        "\n",
        "╭───────────────────────────────────────────────────────── Benchmark Results ──────────────────────────────────────────────────────────╮\n",
        "│ ╭────────────────┬───────────────────────────────────────────────────────────────╮                                                   │\n",
        "│ │ Benchmark Name │ Benchmark Results (sec)                                       │                                                   │\n",
        "│ ├────────────────┼───────────────────────────────────────────────────────────────┤                                                   │\n",
        "│ │ addition       │ [0.315758167009335, 0.3145883330143988, 0.31581891601672396]  │                                                   │\n",
        "│ │ concatenation  │ [1.7665895420359448, 1.76266020903131, 1.7622904580202885]    │                                                   │\n",
        "│ │ exponentiation │ [2.23918766702991, 2.237772374995984, 2.2365284170373343]     │                                                   │\n",
        "│ │ multiplication │ [0.3268889999599196, 0.3260872920509428, 0.324562625028193]   │                                                   │\n",
        "│ │ rangelist      │ [0.08542008401127532, 0.0833578750025481, 0.0837147919810377] │                                                   │\n",
        "│ ╰────────────────┴───────────────────────────────────────────────────────────────╯                                                   │\n",
        "╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n",
        "```\n",
        "\n",
        "##### Windows\n",
        "\n",
        "#### Run of Performance Analysis\n",
        "\n",
        "#### Summary of the results\n",
        "\n",
        "1. **`Array Queue`** is the best for `enqueue` and `dequeue` operations.  \n",
        "   `Enqueue` adds an element to the back of the queue, and `dequeue` removes an element from the front of the queue.\n",
        "\n",
        "   `Array Queue` is the fastest → ~4.5x faster than `SLL` and ~6x faster than `DLL`. The `Array Queue` enqueues 1,000 elements in `0.0437 ms` and dequeues in `0.029 ms`.\n",
        "\n",
        "2. When it comes to concatenation, **`Linked Lists`** (`DLL`/`SLL`) are much better.\n",
        "\n",
        "   `Linked Lists` (`SLL`/`DLL`) excel in concatenation because they can simply link two lists together in `O(1)` time, whereas the `Array Queue` needs to create a new array and copy all elements into it.\n",
        "\n",
        "3. If you want a balance between memory and performance, choose **`SLL`**.ions.\n",
        "\n",
        "---\n",
        "\n",
        "## Recommendations\n",
        "\n",
        "### Use **Array-based Queue**:\n",
        "- When basic operations (`enqueue`, `dequeue`, `peek`) are the primary focus.\n",
        "- When memory efficiency is crucial.\n",
        "- When concatenation operations are rare.\n",
        "\n",
        "### Use **DLL Queue**:\n",
        "- When frequent concatenation is required.\n",
        "- When bidirectional traversal is needed.\n",
        "- When dynamic size changes are common.\n",
        "\n",
        "### Use **SLL Queue**:\n",
        "- When memory efficiency is important.\n",
        "- When unidirectional traversal suffices.\n",
        "- When concatenation operations are frequent.\n",
        "\n",
        "---\n",
        "\n",
        "# Conclusion\n",
        "\n",
        "The choice of queue implementation depends on the specific requirements of the application:\n",
        "- **Array-based Queue** is ideal for basic operations and memory efficiency.\n",
        "- **DLL** is suitable for applications requiring flexibility and frequent concatenation.\n",
        "- **SLL** strikes a balance between memory efficiency and functionality.\n",
        "\n",
        "---\n",
        "\n",
        "# Future Work\n",
        "\n",
        "- Analyze performance under varying workloads and larger data sizes.\n",
        "- Measure memory usage across different implementations.\n",
        "- Explore hybrid implementations that combine the strengths of different approaches."
      ],
      "id": "37823e2c"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/antonhedlund/Library/Caches/pypoetry/virtualenvs/queue-analysis-2LJggUpT-py3.12/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}