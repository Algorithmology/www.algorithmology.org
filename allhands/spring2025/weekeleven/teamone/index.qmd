---
author: [Javier Bejarano Jimenez, Finley Banas, Joseph Oforkansi, Anupraj Guragain, Anton Hedlund]
title: What is the performance difference, measured in time when running a doubling experiment between a SLL queue, a DLL queue and a queue built with an array based list when performing basic operations?
page-layout: full
categories: [post, queues, linked lists, doubling experiment]
date: "2025-03-28"
date-format: long
toc: true
---

# Introduction

Efficient data structures are crucial for software performance, scalability, and responsiveness. Among these, queues are fundamental, supporting applications such as task scheduling, messaging systems, and real-time data processing. This project investigates the performance differences between three queue implementations: Singly Linked List (SLL), Doubly Linked List (DLL), and Array-based Queue. 

Our research question is: **What are the performance differences between SLL queue, DLL queue, and Array-based queue implementations when performing basic operations (e.g., `addfirst`, `addlast`, `removefirst`, `removelast`, `add (+)`, and `iadd (+=)`)?** 

We conducted benchmarking experiments using `SystemSense` to analyze these implementations. Key aspects considered include:

- **Algorithmic Complexity**: Evaluating time and space complexity to identify trade-offs.
- **Concurrency Considerations**: Assessing behavior in multi-threaded environments.
- **Use Case Optimization**: Identifying scenarios where each implementation excels.
- **Benchmarking Methodology**: Designing experiments to measure execution times and scaling behavior.

This project aims to provide insights into the efficiency of these queue implementations and guide the selection of an optimal data structure based on application requirements.

---

## Motivation

Efficient data structures are critical in real-world applications such as scheduling systems, task management, and networking. Different queue implementations offer trade-offs in performance. This project benchmarks these trade-offs to analyze execution times for various queue operations.

---

# Queue Implementations Analysis

## Queue Structure and FIFO Principle

Queues adhere to the **First-In-First-Out (FIFO)** principle, where elements are added at the rear and removed from the front, ensuring sequential processing.

## Implementations Overview

This project explores three queue implementations:

1. **Singly Linked List (SLL) Queue**:
   - Uses one-directional nodes with `next` references.
   - Maintains both head and tail pointers for efficient operations.
   - Each node stores only the value and a `next` reference.

2. **Doubly Linked List (DLL) Queue**:
   - Uses bidirectional nodes with both `prev` and `next` references.
   - Maintains both head and tail pointers.
   - Each node stores value, `prev`, and `next` references.

3. **Array-based Queue**:
   - No explicit node structure; uses a container of elements.
   - Optimized for operations at both ends.

---

### Example Implementations

#### Enqueue Operation (SLL)

```python
def enqueue(self, value: Any) -> None:
    """Add an element to the end of the queue. O(1) operation using tail pointer."""
    new_node = Node(value)
    if self.is_empty():
        self.head = new_node
    else:
        self.tail.next = new_node  # Directly append at tail
    self.tail = new_node  # Update tail pointer
    self.size += 1
```

#### Dequeue Operation (DLL)

```python
def dequeue(self) -> Any:
    """Remove and return the first element from the queue. O(1) operation."""
    if self.is_empty():
        raise IndexError("Queue is empty")
    value = self.head.value
    self.head = self.head.next
    if self.head is None:
        self.tail = None
    else:
        self.head.prev = None
    self.size -= 1
    return value
```

#### Queue Concatenation (Array-based)

```python
def __add__(self, other: Any) -> Any:
    """Concatenate two queues. O(n) operation."""
    result = ListQueueDisplay()
    result.items = deque(self.items)  # Copy first queue
    result.items.extend(other.items)  # Append second queue
    return result
```

---

## Implementation Considerations

### SLL Queue
- **Advantages**:
  - Simpler structure with less memory overhead per node.
  - Efficient concatenation due to the tail pointer.
- **Limitations**:
  - Forward-only traversal limits some operations.

### DLL Queue
- **Advantages**:
  - Bidirectional links enable more flexible operations.
  - Easy traversal in both directions.
- **Limitations**:
  - Higher memory usage due to extra pointers per node.

### Array-based Queue
- **Advantages**:
  - No manual pointer management required.
  - Leverages Python's efficient `deque` implementation.
- **Limitations**:
  - Internal array may require occasional reallocation.

---

## Key Operations

All implementations support the following core operations:

- **`enqueue`**: Add an element to the rear.
- **`dequeue`**: Remove an element from the front.
- **`peek`**: View the front element without removing it.
- **`__add__`**: Concatenate two queues.
- **`__iadd__`**: In-place concatenation. 

# Analysis

We designed two main experiments: **Basic Analysis** and **Doubling Experiment**.

## Basic Analysis

This function evaluates the performance of core operations (`enqueue`, `dequeue`, `peek`, `concat`, and `iconcat`) for a fixed queue size.

```python
def analyze_queue(queue_class, size=1000):
    """Analyze a queue implementation."""
    approach = next(
        (k for k, v in QUEUE_IMPLEMENTATIONS.items() if v == queue_class), None
    )
    if approach is None:
        console.print("[red]Unknown queue implementation[/red]")
        return

    console.print(f"\n{approach.value.upper()} Queue Implementation")

    try:
        queue = queue_class()
        operations = []

        # Test enqueue
        enqueue_time = time_operation(lambda: [queue.enqueue(i) for i in range(size)])
        operations.append(("enqueue", enqueue_time, size))

        # Test dequeue
        dequeue_count = size // 2
        dequeue_time = time_operation(
            lambda: [queue.dequeue() for _ in range(dequeue_count)]
        )
        operations.append(("dequeue", dequeue_time, dequeue_count))

        # Refill queue
        for i in range(dequeue_count):
            queue.enqueue(i)

        # Test peek
        peek_count = size // 3
        peek_time = time_operation(lambda: [queue.peek() for _ in range(peek_count)])
        operations.append(("peek", peek_time, peek_count))

        # Test concat
        other = queue_class()
        for i in range(size // 10):
            other.enqueue(i)
        concat_time = time_operation(lambda: queue + other)
        operations.append(("concat", concat_time, size // 10))

        # Test iconcat
        iconcat_time = time_operation(lambda: queue.__iadd__(other))
        operations.append(("iconcat", iconcat_time, size // 10))

        # Display results in table
        table = Table(
            title=f"{approach.value.upper()} Queue Performance Analysis",
            box=box.ROUNDED,
            show_header=True,
            header_style="bold magenta",
        )
        table.add_column("Operation", style="cyan")
        table.add_column("Time (ms)", justify="right")
        table.add_column("Elements", justify="right")
        table.add_column("Time/Element (ms)", justify="right")

        for operation, time_taken, elements in operations:
            time_per_element = time_taken / elements if elements > 0 else 0
            table.add_row(
                operation,
                f"{time_taken * 1000:.6f}",  # Convert to milliseconds
                f"{elements:,}",
                f"{time_per_element * 1000:.6f}",  # Convert to milliseconds
            )

        console.print(Panel(table))

    except Exception as e:
        console.print(f"[red]Error testing {approach.value}: {str(e)}[/red]")
        import traceback

        console.print(traceback.format_exc())
```

#### Doubling experiment

This experiment measures how performance scales as the input size doubles.

```python

def doubling(
    initial_size: int = typer.Option(100, help="Initial size for doubling experiment"),
    max_size: int = typer.Option(1000, help="Maximum size for doubling experiment"),
    dll: bool = typer.Option(True, help="Test DLL implementation"),
    sll: bool = typer.Option(True, help="Test SLL implementation"),
    array: bool = typer.Option(True, help="Test Array implementation"),
):
    """Run doubling experiment on queue implementations."""
    # Create results directory if it doesn't exist
    results_dir = Path("results")
    results_dir.mkdir(exist_ok=True)

    sizes = []
    current_size = initial_size
    while current_size <= max_size:
        sizes.append(current_size)
        current_size *= 2

    # Dictionary to store all results for plotting
    all_results = {}

    for approach, queue_class in QUEUE_IMPLEMENTATIONS.items():
        if not (
            (approach == QueueApproach.dll and dll)
            or (approach == QueueApproach.sll and sll)
            or (approach == QueueApproach.array and array)
        ):
            continue

        try:
            console.print(f"\n{approach.value.upper()} Queue Implementation")
            results = {
                "enqueue": [],
                "dequeue": [],
                "peek": [],
                "concat": [],
                "iconcat": [],
            }

            for size in sizes:
                queue = queue_class()

                # Enqueue
                enqueue_time = time_operation(
                    lambda: [queue.enqueue(i) for i in range(size)]
                )
                results["enqueue"].append(enqueue_time)

                # Dequeue
                dequeue_time = time_operation(
                    lambda: [queue.dequeue() for _ in range(size // 2)]
                )
                results["dequeue"].append(dequeue_time)

                # Refill queue
                for i in range(size // 2):
                    queue.enqueue(i)

                # Peek
                peek_time = time_operation(
                    lambda: [queue.peek() for _ in range(size // 3)]
                )
                results["peek"].append(peek_time)

                # Concat
                other = queue_class()
                for i in range(size // 10):
                    other.enqueue(i)

                concat_time = time_operation(lambda: queue + other)
                results["concat"].append(concat_time)

                # Iconcat
                iconcat_time = time_operation(lambda: queue.__iadd__(other))
                results["iconcat"].append(iconcat_time)

            # Store results for plotting
            all_results[approach.value] = results

            # Display results in table
            table = Table(
                title=f"{approach.value.upper()} Queue Doubling Experiment Results",
                box=box.ROUNDED,
                show_header=True,
                header_style="bold magenta",
            )
            table.add_column("Size (n)", justify="right")
            for operation in results.keys():
                table.add_column(operation, justify="right")

            for i, size in enumerate(sizes):
                row = [f"{size:,}"]
                for operation in results.keys():
                    value = results[operation][i]
                    if np.isnan(value):  # Check for NaN
                        row.append("N/A")
                    else:
                        row.append(f"{value * 1000:.6f}")  # Convert to milliseconds
                table.add_row(*row)

            console.print(Panel(table))

        except Exception as e:
            console.print(f"[red]Error testing {approach.value}: {str(e)}[/red]")
            import traceback

            console.print(traceback.format_exc())

    # Generate and save plots
    plot_results(sizes, all_results, results_dir)
    console.print(f"[green]Plots saved to [bold]{results_dir}[/bold] directory[/green]")

```

#### Key benchmarking feature

##### Timing Mechanism

```python

def time_operation(func):
    """Time an operation using high-precision counter."""
    try:
        # Warm up
        func()

        # Actual timing
        start_time = perf_counter()
        func()
        elapsed = perf_counter() - start_time
        return elapsed
    except Exception as e:
        console.print(f"[red]Error during operation: {str(e)}[/red]")
        return float("nan")
```

- Uses perf_counter() for high-precision timing
- Includes a warm-up run to avoid cold-start penalties
- Returns elapsed time in seconds

---

## Running and Using the Tool

The benchmarking supports three queue implementations:
- DLL (Doubly Linked List)
- SLL (Singly Linked List)
- Array-based Queue

### Setting Up

To run the benchmarking tool, ensure you have Poetry installed onto your device. Navigate to the project directory and install dependencies if you have not already:

`cd analyze && poetry install`

### Running the Experiments

The tool provides two main benchmarking experiments which can also be access by 

`poetry run analyze --help`

#### Doubling Experiment

To run the doubling experiment, execute:

`poetry run analyze doubling`

This experiment measures how performance will scale with the increasing input sizes. 

You can also run:
`poetry run analyze doubling --help`
for more details and detailed apporach

#### Implementation Performance Analysis

To analyze the performance of individual queue operations, run:

`poetry run analyze analyze`

This command will provide execution times for operations like `peek`, `dequeue`, and `enqueue` to compare their efficiency.

You can also run:
`poetry run analyze analyze --help`
for more details and detailed apporach

## Output Analysis

#### Run of Doubling Experiment

#### Run of Performance Analysis

#### Summary of the results

1. **`Array Queue`** is the best for `enqueue` and `dequeue` operations.  
   `Enqueue` adds an element to the back of the queue, and `dequeue` removes an element from the front of the queue.

   `Array Queue` is the fastest â†’ ~4.5x faster than `SLL` and ~6x faster than `DLL`. The `Array Queue` enqueues 1,000 elements in `0.0437 ms` and dequeues in `0.029 ms`.

2. When it comes to concatenation, **`Linked Lists`** (`DLL`/`SLL`) are much better.

   `Linked Lists` (`SLL`/`DLL`) excel in concatenation because they can simply link two lists together in `O(1)` time, whereas the `Array Queue` needs to create a new array and copy all elements into it.

3. If you want a balance between memory and performance, choose **`SLL`**.ions.

---

## Recommendations

### Use **Array-based Queue**:
- When basic operations (`enqueue`, `dequeue`, `peek`) are the primary focus.
- When memory efficiency is crucial.
- When concatenation operations are rare.

### Use **DLL Queue**:
- When frequent concatenation is required.
- When bidirectional traversal is needed.
- When dynamic size changes are common.

### Use **SLL Queue**:
- When memory efficiency is important.
- When unidirectional traversal suffices.
- When concatenation operations are frequent.

---

# Conclusion

The choice of queue implementation depends on the specific requirements of the application:
- **Array-based Queue** is ideal for basic operations and memory efficiency.
- **DLL** is suitable for applications requiring flexibility and frequent concatenation.
- **SLL** strikes a balance between memory efficiency and functionality.

---

# Future Work

- Analyze performance under varying workloads and larger data sizes.
- Measure memory usage across different implementations.
- Explore hybrid implementations that combine the strengths of different approaches.

# References

1. Documentation
    - [Python deque](https://docs.python.org/3/library/collections.html#collections.deque)
    - [SLL and DLL](https://www.geeksforgeeks.org/difference-between-singly-linked-list-and-doubly-linked-list/)
    - [Python's collections](https://realpython.com/python-collections-module/)
    - [Linked Lists](https://cs50.harvard.edu/x/2023/notes/5/)

2. Books
    - "A First Course on Data Structures in Python"
    - "Data Structures and Algorithm Analysis in C++" by Mark Allen Weiss
    - "Introduction to Computation and Programming Using Python"

3. Course Slides
    - [Implementing Linked-Based Data Structures](https://algorithmology.org/slides/weeknine/#/title-slide)

## AI

- **Queue Implementation Design**: AI assisted in designing and refining the implementations of Singly Linked List (SLL), Doubly Linked List (DLL), and Array-based queues. It provided suggestions for optimizing the `enqueue`, `dequeue`, and concatenation operations.
- **Code Optimization and Refactoring**: AI provided recommendations to improve the performance and readability of the codebase. For example, it helped optimize the `time_operation` function for precise benchmarking and reduced redundant computations in queue operations.
- **Benchmarking Experiment Design**: AI helped me to the design of the doubling experiment and basic analysis, ensuring that the experiments effectively measured performance differences across queue implementations.

All AI-generated content was reviewed and validated by team members.