---
author: [Hemani Alaparthi, Duru Akbas, Williem Bennet, Faaris Cheema, Vivian Potts]
title: How do linear search, binary search, balanced BSTs compare in runtime efficiency across varying dataset sizes and target positions?
page-layout: full
categories: [post, linear search, binary search, binary search tree, search]
date: "2025-04-24"
date-format: long
toc: true
format:
    html:
        code-links:    
            - text: Github Repository
              icon: github
              href: https://github.com/hemanialaparthi/lvb
---

# Introduction

This study examines how `linear search`, `binary search`, and `balanced binary search tree (BST)` algorithms perform under varying conditions, specifically looking at:

1. How dataset size affects performance scaling
2. How target element position impacts search efficiency

# Motivation

While `linear search` `(O(n))` offers simplicity and `binary search`/`balanced BSTs` `(O(log n))` promise theoretical efficiency, real-world performance depends heavily on:

1. Dataset growth patterns

2. Target location distributions

3. Hardware/platform characteristics

Our benchmarking provides empirical insights to guide algorithm selection in production systems where theoretical models may not reflect actual behavior.

# Method

For this experiment, we developed a benchmarking tool that allows for systematic comparison between search algorithms across different data structures. The tool measures execution time while controlling for:

1. Data structure type (`unsorted list`, `sorted list` and `binary search tree`)
2. Search algorithm (`linear search` vs. `binary search` vs. `BST search`)
3. Dataset size (with automatic doubling between runs)
4. Target position (`beginning`, `middle`, `end`, `random`, or `nonexistent`)

# Approach

## Linear Search

```cmd
def linear_search(dataset: List[Any], target: Any) -> Optional[int]:
    """Perform a linear search on the dataset.

    Args:
        dataset: List to search through
        target: Element to search for

    Returns:
        int: Index of the target element, or None if not found
    """
    # Iterate through the dataset
    for i, item in enumerate(dataset):
        if item == target:
            return i

    # Target not found
    return None
```

Linear search sequentially checks each element until finding the target or reaching the end. It works on both sorted and unsorted data with `O(n)` time complexity.

## Binary Search

TODO

## Binary Search Tree

TODO

# Data

We conducted experiments with datasets of `1,000` and `5,000` elements, using both sorted and unsorted arrays. For each algorithm, we measured:

1. Performance across different dataset sizes
2. Impact of target position (`beginning`, `middle`, `end`, or `nonexistent`)
3. Runtime consistency across multiple searches (`100` and `500` searches)

# Data Tables

### MacOS

### Windows

### Results

# Conclusion

# TODO

# Future Work

Several areas for future investigation could provide additional insights:

- **Floating-point comparison overhead might affect the relative performance advantages**
    - Decimal comparisons introduce additional computational overhead and potential precision issues that could affect performance differently across algorithms. This would be particularly relevant for scientific computing and financial applications where decimal data is common.

# References

- [Linear vs Binary Search](https://www.geeksforgeeks.org/linear-search-vs-binary-search/)
- [Binary Search Tree](https://www.geeksforgeeks.org/introduction-to-binary-search-tree/)
