---
author: [Benedek Kaibas, Chloe Bonson, David Gormley, Mordred Boulais, William Wolff, Luke Barker]
title: Investigating the efficiency of computing counting and reversing a string 
page-layout: full
categories: [post, dictionaries, strings]
date: "2024-03-22"
date-format: long
toc: true
---

# Overview

An analysis of the running time and run time of the assorted `reverse_count`
functions implemented by team members.

# Code 

# TODO: Modify this to include your code in place of mine - I'll clean up merge conflicts later.

```{python}
# Chloe's implementation of the function reverse_count

### Function Implementation
def reverse_count(data: str) -> dict:
    """Reverse the content of the provided string and return it in a mapping."""
    reverse = data[::-1]
    return {data: {"count": str(len(data)), "reversed": reverse}}
```

```{python}
import timeit
import functools

# Rough draft of potential analysis script.
performance_list = []
for i in timeit.repeat(
  stmt=functools.partial(reverse_count, "checking!"),
    number=10,
  ):
    performance_list.append(i)
print(
  f"Performance time in seconds:\n {performance_list}"
)
```

# Output

From Chloe's implementation:

Performance time in seconds:[6.667338311672211e-06, 2.2919848561286926e-06, 2.1248124539852142e-06, 2.125278115272522e-06, 2.00001522898674e-06]

# Analysis/Conclusion

Based on the output above, the running time exhibits a worst case time complexity of O(n), otherwise described as a linear progression. This means that there is a linear relationship between the runtime of the function and the input size. I considred the costs of slicing the str (`reverse = data[::-1]`) and creating the dictionary with the len function involved (`data: {"count": str(len(data)), "reversed": reverse}`) O(n). Leading to the total WCTC being the same.

The runtime of the function implementation above is displayed in the Ouput section. The average of the 5 output values is 3.0418857932090757e-06. Comapring the running time to the runtime results, it is indicated that as the string input `data` is increased, there will be a constant rate of growth. Graphically, this would be visualized with time on the x axis and input size on the y axis; the curve would be a straight line with a positive slope.

Comparing the theoretical running time value and the empirical run time results, do not indicate what I would expect. The results seem to be rather constant as input increases, rtaher than a linear growth rate. This could be for multiple reasons, however, the prominent factor I thought of was that I did not increase the input substantially enough. For instance, it was not feasible for me to add millions of characters to the input string. Perhaps having more characters to 