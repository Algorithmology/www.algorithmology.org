---
author: [Miles Franck, Aidan Dyga, Nicholas Ingerson-Meacham, Simon Jones, Pallas-Athena Cain, Jason Gyamfi]
title: How does a container's memory overhead influence the time efficiency of containment checking?
page-layout: full
categories: [post, containment checking, lists]
date: "2024-02-16"
date-format: long
toc: true
---

# Introduction

When programming in Python each object created takes up a specific amount of space on the computer which is measured in bytes. The objects themselves hold their names as well as their properties. In the `containmentcheck` program we are looking in particular at container objects that also store the values inside of them, sometimes pointer values. In this post, we will be experimenting to see how much of an impact the size of an object has on the time efficiency of the `containmentcheck` program. 

## Motivation

As society’s programs get more complex, computer memory is becoming an increasingly more valuable resource. When programming it is important to consider how the type of objects you use will impact your program’s performance. The goal of our experiments is to look at how the size of the container impacts the amount of space a program takes up and whether or not that causes an increase or decrease in the speed of the program's runtime itself. 

# Method

## Part One 

For the first part of our experiment, we compared the runtimes of the 3 types of containers used in our `containmentcheck` program, the list, tuple, and set. We used the `sys.getsizeof()` function to find the size, in bytes, of the current container. 

Here is an example of using the `sys.getsizeof()` function:
TODO: check that this example code works
```{
import sys

list_example = [10, 2.0, "cat"]
tuple_example = (10, 2.0, "cat")
set_example = set([10, 2.0, "cat"])

print(sys.getsizeof(list_example))
print(sys.getsizeof(tuple_example))
print(sys.getsizeof(set_example))
}```

As you can see in the following charts, when the container size increases, so does the number of bytes it takes up. This experiment was run at a container size of 10000,  1000000, and 100000000.

The results are as follows:

TODO: ADD MD DATA CHARTS FROM EVERYONE

Result from running on WSL2

| Approach | Container Size | Maximum values | Total Time for 10 runs| Average Time for 10 runs| Size in Bytes|
|:--------:|:--------------:|:--------------:|:-----:|:-----:|:-----:|
|   list   |   10000   |     100000   | [0.0012522619999799645, 0.0012322780003160005, 0.0011758390010072617]  | [0.00012522619999799645, 0.00012322780003160005, 0.00011758390010072617]  | 85176  |
|   tuple   |   10000   |     100000   | [0.0006548499986820389, 0.0006511610008601565, 0.0006510949988296488]  | [6.548499986820388e-05, 6.511610008601565e-05, 6.510949988296489e-05] | 80040  |
|   set   |   10000  |     100000   | [0.004011396000350942, 0.0035747010006161872, 0.003517425999234547]  | [0.0004011396000350942, 0.00035747010006161874, 0.0003517425999234547]  | 85176  |
|  list   |   1000000   |     100000    | [0.10512661299981119, 0.10005645099954563, 0.13408000599883962]  | [0.01051266129998112, 0.010005645099954562, 0.013408000599883962]  | 8448728  |
|  tuple   |   1000000   |     100000   | [0.22520549799992295, 0.08570071100075438, 0.14284700400094152] | [0.022520549799992295, 0.008570071100075438, 0.014284700400094153]  | 8000040  |
|  set   |   1000000   |     100000   | [1.0035714010009542, 0.5476638039999671, 0.5286222340000677]  | [0.10035714010009542, 0.054766380399996706, 0.05286222340000677]  | 8448728  |
|   list   |   100000000   |     100000   | [11.542406832999404, 10.57156037599998, 10.508643252998809]  |[1.1542406832999403, 1.057156037599998, 1.0508643252998808]  | 835128600  |
|   tuple    |   100000000   |     100000   |[9.33974368499912, 8.946416168999349, 8.583650802000193]  | [0.9339743684999121, 0.8946416168999349, 0.8583650802000193]  | 800000040  |
|   set    |   100000000   |     100000   | [104.86943111599976, 87.68656122200082, 102.34969667100086] | [10.486943111599976, 8.768656122200081, 10.234969667100085]  | 835128600 |

Result from running on NixOS 22.11 (x86_64)

| Approach | Container Size | Maximum values | Total Time for 10 runs                                                | Average Time for 10 runs                                                | Size in Bytes |
|:--------:|:--------------:|:--------------:|:---------------------------------------------------------------------:|:-----------------------------------------------------------------------:|:-------------:|
| list     | 10000          | 100000         | [0.0008414719999336739, 0.0008432590000211349, 0.0008199860000104309] | [8.41471999933674e-05, 8.432590000211349e-05, 8.199860000104308e-05]    | 85176         |
| tuple    | 10000          | 100000         | [0.0007369920000428465, 0.0007288279999784208, 0.0007277400000020862] | [7.369920000428465e-05, 7.288279999784208e-05, 7.277400000020862e-05]   | 80040         |
| set      | 10000          | 100000         | [0.0039581030000590545, 0.003329724000082024, 0.003341187000046375]   | [0.00039581030000590545, 0.0003329724000082024, 0.0003341187000046375]  | 85176         |
| list     | 1000000        | 100000         | [0.004278331000023172, 0.003928750999989461, 0.004035653999949318]    | [0.0004278331000023172, 0.0003928750999989461, 0.0004035653999949318]   | 8448728       |
| tuple    | 1000000        | 100000         | [0.004301209999994171, 0.004104619000031562, 0.004039459999944484]    | [0.00043012099999941713, 0.0004104619000031562, 0.00040394599999444837] | 8000040       |
| set      | 1000000        | 100000         | [0.7286783740000828, 0.7370151210000131, 0.724985429999947]           | [0.07286783740000828, 0.07370151210000131, 0.0724985429999947]          | 8448728       |
| list     | 100000000      | 100000         | [0.007804205999946134, 0.00784077499997693, 0.00784397600000375]      | [0.0007804205999946134, 0.000784077499997693, 0.000784397600000375]     | 835128600     |
| tuple    | 100000000      | 100000         | [0.0015112060000319616, 0.0014411099999733779, 0.0014386159999730808] | [0.00015112060000319616, 0.00014411099999733779, 0.0001438615999973081] | 800000040     |
| set      | 100000000      | 100000         | [83.146080407, 85.06266644699986, 82.90463120200002]                  | [8.3146080407, 8.506266644699986, 8.290463120200002]                    | 835128600     |

The following graphs show that for all three container types, there is a positive correlation between the size of the container and the amount of time it takes to process. Despite having different sizes in bytes, tuples and lists have nearly the same performance with tuples performing slightly better overall. Lists are larger containers but from the results, their size increase does not exactly correlate to the process speed. Sets have the same byte size as lists do but provide much slower results. The following scatter plots demonstrate the time versus the bytes. As you can see, lists are slightly slower than tuples but not by the same margin of the set's slower speed. This case makes it appear that the size in bytes did not cause as much of an impact to the program as did the type of the container itself.

TODO: INSERT THE SCATTER PLOTS

However, this does not explain the entirety of the picture of how bytes impact runtime. To get a better understanding of the relationship we can look at the program’s overall memory usage.

## Part Two 

Memory usage can be difficult to measure in Python in particular. Because Python automatically allocates memory for objects behind the scenes it can be tricky to know exactly what is happening (Turner-Trauring, 2021).

There are three main cases where our containers may be stored. They can be stored in either RAM, the disk (swap), or both (Turner-Trauring, 2021). As a fourth option, the program may not be even stored at all. 
For the main three cases, the number of processes running in the background will decide where it is stored. For example, if there are a lot of browser tabs being run in the background the computer will likely switch things over to using the disk memory or swap. This is our resident memory usage. 

TODO: INCLUDE PART ABOUT TRACEMALLOC

# Results

TODO:

# Slides

TODO:

# Source Code Examples

TODO: 

# References

[1] Itamar Turner-Trauring, “Measuring memory usage in Python: it’s tricky!,” Python⇒Speed, Jun. 21, 2021. https://pythonspeed.com/articles/measuring-memory-python/#:~:text=In%20Python%20 (accessed Feb. 11, 2024).
‌[2] Itamar Turner-Trauring, “Easy Python memory profiling for data scientists and scientists with Fil,” Python⇒Speed, 2023. https://pythonspeed.com/fil/ (accessed Feb. 11, 2024).



