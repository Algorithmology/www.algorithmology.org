---
author: [Miles Franck, Aidan Dyga, Nicholas Ingerson-Meacham, Simon Jones, Pallas-Athena Cain, Jason Gyamfi]
title: How does a container's memory overhead influence the time efficiency of containment checking?
page-layout: full
categories: [post, containment checking, lists]
date: "2024-02-16"
date-format: long
toc: true
---

# Introduction

When programming in Python each object created takes up a specific amount of space on the computer which is measured in bytes. The objects themselves hold their names as well as their properties. In the `containmentcheck` program we are looking in particular at container objects that also store the values inside of them, sometimes pointer values. In this post, we will be experimenting to see how much of an impact the size of an object has on the time efficiency of the `containmentcheck` program. 

## Motivation

As society’s programs get more complex, computer memory is becoming an increasingly more valuable resource. When programming it is important to consider how the type of objects you use will impact your program’s performance. The goal of our experiments is to look at how the size of the container impacts the amount of space a program takes up and whether or not that causes an increase or decrease in the speed of the program's runtime itself. 

# Method

## Part One 

For the first part of our experiment, we compared the runtimes of the 3 types of containers used in our `containmentcheck` program, the list, tuple, and set. We used the `sys.getsizeof()` function to find the size, in bytes, of the current container. 

Here is an example of using the `sys.getsizeof()` function:
TODO: check that this example code works
```{
import sys

list_example = [10, 2.0, "cat"]
tuple_example = (10, 2.0, "cat")
set_example = set([10, 2.0, "cat"])

print(sys.getsizeof(list_example))
print(sys.getsizeof(tuple_example))
print(sys.getsizeof(set_example))
}```

As you can see in the following charts, when the container size increases, so does the number of bytes it takes up. This experiment was run at a container size of 10000,  1000000, and 100000000.

The results are as follows:

TODO: ADD MD DATA CHARTS FROM EVERYONE

Result from running on WSL2

| Approach | Container Size | Maximum values | Total Time for 10 runs| Average Time for 10 runs| Size in Bytes|
|:--------:|:--------------:|:--------------:|:-----:|:-----:|:-----:|
|   list   |   10000   |     100000   | [0.0012522619999799645, 0.0012322780003160005, 0.0011758390010072617]  | [0.00012522619999799645, 0.00012322780003160005, 0.00011758390010072617]  | 85176  |
|   tuple   |   10000   |     100000   | [0.0006548499986820389, 0.0006511610008601565, 0.0006510949988296488]  | [6.548499986820388e-05, 6.511610008601565e-05, 6.510949988296489e-05] | 80040  |
|   set   |   10000  |     100000   | [0.004011396000350942, 0.0035747010006161872, 0.003517425999234547]  | [0.0004011396000350942, 0.00035747010006161874, 0.0003517425999234547]  | 85176  |
|  list   |   1000000   |     100000    | [0.10512661299981119, 0.10005645099954563, 0.13408000599883962]  | [0.01051266129998112, 0.010005645099954562, 0.013408000599883962]  | 8448728  |
|  tuple   |   1000000   |     100000   | [0.22520549799992295, 0.08570071100075438, 0.14284700400094152] | [0.022520549799992295, 0.008570071100075438, 0.014284700400094153]  | 8000040  |
|  set   |   1000000   |     100000   | [1.0035714010009542, 0.5476638039999671, 0.5286222340000677]  | [0.10035714010009542, 0.054766380399996706, 0.05286222340000677]  | 8448728  |
|   list   |   100000000   |     100000   | [11.542406832999404, 10.57156037599998, 10.508643252998809]  |[1.1542406832999403, 1.057156037599998, 1.0508643252998808]  | 835128600  |
|   tuple    |   100000000   |     100000   |[9.33974368499912, 8.946416168999349, 8.583650802000193]  | [0.9339743684999121, 0.8946416168999349, 0.8583650802000193]  | 800000040  |
|   set    |   100000000   |     100000   | [104.86943111599976, 87.68656122200082, 102.34969667100086] | [10.486943111599976, 8.768656122200081, 10.234969667100085]  | 835128600 |


The following graphs show that for all three container types, there is a positive correlation between the size of the container and the amount of time it takes to process. Despite having different sizes in bytes, tuples and lists have nearly the same performance with tuples performing slightly better overall. Lists are larger containers but from the results, their size increase does not exactly correlate to the process speed. Sets have the same byte size as lists do but provide much slower results. The following scatter plots demonstrate the time versus the bytes. As you can see, lists are slightly slower than tuples but not by the same margin of the set's slower speed. This case makes it appear that the size in bytes did not cause as much of an impact to the program as did the type of the container itself.

![scatter-plot-small](/images/scatter-plot-small.PNG) 

![scatter-plot-medium](/images/scatter-plot-medium.PNG) 

![scatter-plot-large](/images/scatter-plot-large.PNG) 

However, this does not explain the entirety of the picture of how bytes impact runtime. To get a better understanding of the relationship we can look at the program’s overall memory usage.

## Part Two

Memory usage can be difficult to measure in Python in particular. Because Python automatically allocates memory for objects behind the scenes it can be tricky to know exactly what is happening (Turner-Trauring, 2021).

There are three main cases where our containers may be stored. They can be stored in either RAM, the disk (swap), or both (Turner-Trauring, 2021). As a fourth option, the program may not be even stored at all. 
For the main three cases, the number of processes running in the background will decide where it is stored. For example, if there are a lot of browser tabs being run in the background the computer will likely switch things over to using the disk memory or swap. This is our resident memory usage. 

### Tracemalloc

The `tracemalloc` library is a tool that lets you trace the amount of memory that is allocated by a Python program. In this experiment we were able to use `tracemalloc` to get the total amount of traced memory from the program as well as the total allocated size of the program itself (“tracemalloc — Trace memory allocations”, 2024).

The following chart demonstrates the increase in traced memory and allocated size. We were not able to gather results from a container size of 100000000 because it took so much memory it caused our systems to crash. The sizes were found using the `get_traced_memory()` function within the `tracemalloc` library.

| Approach | Container Size | Maximum Values  | Container Size in Bytes | Traced Memory (current size and peak size of memory blocks) | Total allocated size | Container % of Allocated Size | Average Time                                                           |
|----------|----------------|-----------------|-------------------------|-------------------------------------------------------------|----------------------|-------------------------------|------------------------------------------------------------------------|
| list     | 10000          | 100000          | 85176                   | (478365, 494215)                                            | 472.3 KB             | 18%                           | [0.00032951530010905117, 9.121420007431879e-05, 9.334509959444404e-05] |
| tuple    | 10000          | 100000          | 80040                   | (472056, 547288)                                            | 466.4 KiB            | 17.1%                         | [5.88577997405082e-05, 5.23020004038699e-05, 0.00028640130040002987]   |
| set      | 10000          | 100000          | 85176                   | (478179, 1124535)                                           | 471.6 KiB            | 18%                           | [0.0003431481003644876, 0.00028521530039142816, 0.0005371351988287642] |
| list     | 1000000        | 100000          | 8448728                 | (40440727, 40456850)                                        | 39497.4 KiB          | 21%                           | [0.008970955600671005, 0.009021504299016669, 0.010781448800116777]     |
| tuple    | 1000000        | 100000          | 8000040                 | (39996088, 48434760)                                        | 39064.0 KiB          | 20.4%                         | [0.007188823199248873, 0.008647420699708164, 0.010213346801174339]     |
| set      | 1000000        | 100000          | 8448728                 | (40440469, 46722864)                                        | 39497.2 KiB          | 21%                           | [0.48832026500895154, 0.6909954479924636, 0.5341905749955913]          |
| list     | 100000000      | 100000          | 835128600               | N/A                                                         | N/A                  | N/A                           | N/A                                                                    |
| tuple    | 100000000      | 100000          | 800000040               | N/A                                                         | N/A                  | N/A                           | N/A                                                                    |
| set      | 100000000      | 100000          | 835128600               | N/A                                                         | N/A                  | N/A                           | N/A                                                                    |

Another utility of the `tracemalloc` library is the `take_snapshot()` method. This method allows the user to see snapshots of the memory blocks that are allocated by Python itself. The snapshot will provide an output of the memory blocks traced by `tracemalloc` in order of the one that takes up the most space. This is the output from running with the 1000000 size tuple.

```python
Top 10 lines
#1: /nix/store/5k91mg4qjylxbfvrv748smfh51ppjq0g-python3-3.11.6/lib/python3.11/random.py:344: 311.8 KiB
    return istart + self._randbelow(width)
#2: ../containmentcheck/containmentcheck/generate.py:30: 78.2 KiB
    return tuple(random_list)  # or return tuple(random_list)
#3: ../containmentcheck/.venv/lib/python3.11/site-packages/rich/_lru_cache.py:27: 7.9 KiB
    OrderedDict.__setitem__(self, key, value)
#4: /nix/store/5k91mg4qjylxbfvrv748smfh51ppjq0g-python3-3.11.6/lib/python3.11/re/_parser.py:615: 7.3 KiB
    setappend((RANGE, (lo, hi)))
#5: /nix/store/5k91mg4qjylxbfvrv748smfh51ppjq0g-python3-3.11.6/lib/python3.11/re/_parser.py:220: 5.5 KiB
    self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
#6: /nix/store/5k91mg4qjylxbfvrv748smfh51ppjq0g-python3-3.11.6/lib/python3.11/re/_compiler.py:759: 5.3 KiB
    return _sre.compile(
#7: ../containmentcheck/.venv/lib/python3.11/site-packages/rich/cells.py:29: 4.4 KiB
    total_size = sum(_get_size(character) for character in text)
#8: /nix/store/5k91mg4qjylxbfvrv748smfh51ppjq0g-python3-3.11.6/lib/python3.11/re/_parser.py:701: 4.3 KiB
    subpattern[-1] = (MAX_REPEAT, (min, max, item))
#9: ../containmentcheck/.venv/lib/python3.11/site-packages/rich/text.py:672: 4.1 KiB
    style_map = {index: get_style(span.style) for index, span in enumerated_spans}
#10: /nix/store/5k91mg4qjylxbfvrv748smfh51ppjq0g-python3-3.11.6/lib/python3.11/re/_parser.py:545: 2.5 KiB
    subpatternappend((LITERAL, _ord(this)))
74 other: 35.2 KiB
Total allocated size: 466.4 KiB
```

The list and set snapshots demonstrate a difference in the amount of space allocated in the second line.

List Snapshot:

```
#1: /nix/store/5k91mg4qjylxbfvrv748smfh51ppjq0g-python3-3.11.6/lib/python3.11/random.py:344: 312.0 KiB
    return istart + self._randbelow(width)
#2: /home/palla/computer-science-202-algorithm-analysis-project-2-PCain02/containmentcheck/containmentcheck/generate.py:27: 83.1 KiB
    random_list.append(random.randint(0, maximum))
...
Total allocated size: 472.3 KiB
```

Set Snapshot:

```
#1: /nix/store/5k91mg4qjylxbfvrv748smfh51ppjq0g-python3-3.11.6/lib/python3.11/random.py:344: 311.7 KiB
    return istart + self._randbelow(width)
#2: /home/palla/computer-science-202-algorithm-analysis-project-2-PCain02/containmentcheck/containmentcheck/generate.py:27: 83.1 KiB
    random_list.append(random.randint(0, maximum))
...
Total allocated size: 471.6 KiB
```

Overall, the snapshot size of the list and the set are almost equal where as the tuple dislays less storage usage overall. This is consistent with our previous results.

The snapshot can be extremely helpful because it gives us a visualization of the space overhead from each process run by the program. As we can see the top line takes up over half of the amount of space traced by `tracemalloc`. From this output we can also see that the process of creating the random integers takes up majority of the space overhead. The integers created will also create a variation in size depending on the number of bytes they take up individually.

Overall, `tracemalloc` can be utilized outside of this project to visualize the amount of space parts of a program use. The amount of space overhead is consistently larger in the sets and lists than the tuple container.

# Results

TODO: Finish Results Part 1

For the future of this experiment we would hope to be able to test the large container size using `tracemalloc`. This would provide us with more conclusive data about the correlation between container size and traced memory and allocated size. From the tests we were able to run there is a definite positive correlation between the size of the container and the total amount of memory used overall. The larger the container, the more storage will be allocated to the program.

# Slides

TODO:

# Source Code Examples

TODO: 

# References

[1] Itamar Turner-Trauring, “Measuring memory usage in Python: it’s tricky!,” Python⇒Speed, Jun. 21, 2021. https://pythonspeed.com/articles/measuring-memory-python/#:~:text=In%20Python%20 (accessed Feb. 11, 2024).
‌[2] Itamar Turner-Trauring, “Easy Python memory profiling for data scientists and scientists with Fil,” Python⇒Speed, 2023. https://pythonspeed.com/fil/ (accessed Feb. 11, 2024).
[3]“tracemalloc — Trace memory allocations,” Python documentation, 2024. https://docs.python.org/3/library/tracemalloc.html (accessed Feb. 15, 2024).
‌



